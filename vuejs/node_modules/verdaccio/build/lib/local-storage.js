"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _url = _interopRequireDefault(require("url"));

var _lodash = _interopRequireDefault(require("lodash"));

var _localStorage = _interopRequireDefault(require("@verdaccio/local-storage"));

var _streams = require("@verdaccio/streams");

var _pluginLoader = _interopRequireDefault(require("../lib/plugin-loader"));

var _utils = require("./utils");

var _storageUtils = require("./storage-utils");

var _constants = require("./constants");

var _cryptoUtils = require("./crypto-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Implements Storage interface (same for storage.js, local-storage.js, up-storage.js).
 */
class LocalStorage {
  constructor(config, logger) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "storagePlugin", void 0);

    _defineProperty(this, "logger", void 0);

    this.logger = logger.child({
      sub: 'fs'
    });
    this.config = config;
    this.storagePlugin = this._loadStorage(config, logger);
  }

  addPackage(name, pkg, callback) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound('this package cannot be added'));
    }

    storage.createPackage(name, (0, _storageUtils.generatePackageTemplate)(name), err => {
      // FIXME: it will be fixed here https://github.com/verdaccio/verdaccio/pull/1360
      // @ts-ignore
      if (_lodash.default.isNull(err) === false && (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT)) {
        return callback(_utils.ErrorCode.getConflict());
      }

      const latest = (0, _utils.getLatestVersion)(pkg);

      if (_lodash.default.isNil(latest) === false && pkg.versions[latest]) {
        return callback(null, pkg.versions[latest]);
      }

      return callback();
    });
  }
  /**
   * Remove package.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */


  removePackage(name, callback) {
    const storage = this._getLocalStorage(name);

    this.logger.debug({
      name
    }, `[storage] removing package @{name}`);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    storage.readPackage(name, (err, data) => {
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils.ErrorCode.getNotFound());
        }

        return callback(err);
      }

      data = (0, _storageUtils.normalizePackage)(data);
      this.storagePlugin.remove(name, removeFailed => {
        if (removeFailed) {
          // This will happen when database is locked
          this.logger.debug({
            name
          }, `[storage/removePackage] the database is locked, removed has failed for @{name}`);
          return callback(_utils.ErrorCode.getBadData(removeFailed.message));
        }

        storage.deletePackage(_constants.STORAGE.PACKAGE_FILE_NAME, err => {
          if (err) {
            return callback(err);
          }

          const attachments = Object.keys(data._attachments);

          this._deleteAttachments(storage, attachments, callback);
        });
      });
    });
  }
  /**
   * Synchronize remote package info with the local one
   * @param {*} name
   * @param {*} packageInfo
   * @param {*} callback
   */


  updateVersions(name, packageInfo, callback) {
    this._readCreatePackage(name, (err, packageLocalJson) => {
      if (err) {
        return callback(err);
      }

      let change = false; // updating readme

      packageLocalJson.readme = (0, _storageUtils.getLatestReadme)(packageInfo);

      if (packageInfo.readme !== packageLocalJson.readme) {
        change = true;
      }

      for (const versionId in packageInfo.versions) {
        if (_lodash.default.isNil(packageLocalJson.versions[versionId])) {
          let version = packageInfo.versions[versionId]; // we don't keep readme for package versions,
          // only one readme per package

          version = (0, _storageUtils.cleanUpReadme)(version);
          version.contributors = (0, _storageUtils.normalizeContributors)(version.contributors);
          change = true;
          packageLocalJson.versions[versionId] = version;

          if (version.dist && version.dist.tarball) {
            const urlObject = _url.default.parse(version.dist.tarball);

            const filename = urlObject.pathname.replace(/^.*\//, ''); // we do NOT overwrite any existing records

            if (_lodash.default.isNil(packageLocalJson._distfiles[filename])) {
              const hash = packageLocalJson._distfiles[filename] = {
                url: version.dist.tarball,
                sha: version.dist.shasum
              };
              /* eslint spaced-comment: 0 */
              // $FlowFixMe

              const upLink = version[Symbol.for('__verdaccio_uplink')];

              if (_lodash.default.isNil(upLink) === false) {
                this._updateUplinkToRemoteProtocol(hash, upLink);
              }
            }
          }
        }
      }

      for (const tag in packageInfo[_constants.DIST_TAGS]) {
        if (!packageLocalJson[_constants.DIST_TAGS][tag] || packageLocalJson[_constants.DIST_TAGS][tag] !== packageInfo[_constants.DIST_TAGS][tag]) {
          change = true;
          packageLocalJson[_constants.DIST_TAGS][tag] = packageInfo[_constants.DIST_TAGS][tag];
        }
      }

      for (const up in packageInfo._uplinks) {
        if (Object.prototype.hasOwnProperty.call(packageInfo._uplinks, up)) {
          const need_change = !(0, _utils.isObject)(packageLocalJson._uplinks[up]) || packageInfo._uplinks[up].etag !== packageLocalJson._uplinks[up].etag || packageInfo._uplinks[up].fetched !== packageLocalJson._uplinks[up].fetched;

          if (need_change) {
            change = true;
            packageLocalJson._uplinks[up] = packageInfo._uplinks[up];
          }
        }
      }

      if ('time' in packageInfo && !_lodash.default.isEqual(packageLocalJson.time, packageInfo.time)) {
        packageLocalJson.time = packageInfo.time;
        change = true;
      }

      if (change) {
        this.logger.debug({
          name
        }, 'updating package @{name} info');

        this._writePackage(name, packageLocalJson, function (err) {
          callback(err, packageLocalJson);
        });
      } else {
        callback(null, packageLocalJson);
      }
    });
  }
  /**
   * Add a new version to a previous local package.
   * @param {*} name
   * @param {*} version
   * @param {*} metadata
   * @param {*} tag
   * @param {*} callback
   */


  addVersion(name, version, metadata, tag, callback) {
    this._updatePackage(name, (data, cb) => {
      // keep only one readme per package
      data.readme = metadata.readme; // TODO: lodash remove

      metadata = (0, _storageUtils.cleanUpReadme)(metadata);
      metadata.contributors = (0, _storageUtils.normalizeContributors)(metadata.contributors);
      const hasVersion = data.versions[version] != null;

      if (hasVersion) {
        return cb(_utils.ErrorCode.getConflict());
      } // if uploaded tarball has a different shasum, it's very likely that we have some kind of error


      if ((0, _utils.isObject)(metadata.dist) && _lodash.default.isString(metadata.dist.tarball)) {
        const tarball = metadata.dist.tarball.replace(/.*\//, '');

        if ((0, _utils.isObject)(data._attachments[tarball])) {
          if (_lodash.default.isNil(data._attachments[tarball].shasum) === false && _lodash.default.isNil(metadata.dist.shasum) === false) {
            if (data._attachments[tarball].shasum != metadata.dist.shasum) {
              const errorMessage = `shasum error, ${data._attachments[tarball].shasum} != ${metadata.dist.shasum}`;
              return cb(_utils.ErrorCode.getBadRequest(errorMessage));
            }
          }

          const currentDate = new Date().toISOString(); // some old storage do not have this field #740

          if (_lodash.default.isNil(data.time)) {
            data.time = {};
          }

          data.time['modified'] = currentDate;

          if ('created' in data.time === false) {
            data.time.created = currentDate;
          }

          data.time[version] = currentDate;
          data._attachments[tarball].version = version;
        }
      }

      data.versions[version] = metadata;
      (0, _utils.tagVersion)(data, version, tag);
      this.storagePlugin.add(name, addFailed => {
        if (addFailed) {
          return cb(_utils.ErrorCode.getBadData(addFailed.message));
        }

        cb();
      });
    }, callback);
  }
  /**
   * Merge a new list of tags for a local packages with the existing one.
   * @param {*} pkgName
   * @param {*} tags
   * @param {*} callback
   */


  mergeTags(pkgName, tags, callback) {
    this._updatePackage(pkgName, (data, cb) => {
      /* eslint guard-for-in: 0 */
      for (const tag in tags) {
        // this handle dist-tag rm command
        if (_lodash.default.isNull(tags[tag])) {
          delete data[_constants.DIST_TAGS][tag];
          continue;
        }

        if (_lodash.default.isNil(data.versions[tags[tag]])) {
          return cb(this._getVersionNotFound());
        }

        const version = tags[tag];
        (0, _utils.tagVersion)(data, version, tag);
      }

      cb(null);
    }, callback);
  }
  /**
   * Return version not found
   * @return {String}
   * @private
   */


  _getVersionNotFound() {
    return _utils.ErrorCode.getNotFound(_constants.API_ERROR.VERSION_NOT_EXIST);
  }
  /**
   * Return file no available
   * @return {String}
   * @private
   */


  _getFileNotAvailable() {
    return _utils.ErrorCode.getNotFound('no such file available');
  }
  /**
   * Update the package metadata, tags and attachments (tarballs).
   * Note: Currently supports unpublishing and deprecation.
   * @param {*} name
   * @param {*} incomingPkg
   * @param {*} revision
   * @param {*} callback
   * @return {Function}
   */


  changePackage(name, incomingPkg, revision, callback) {
    if (!(0, _utils.isObject)(incomingPkg.versions) || !(0, _utils.isObject)(incomingPkg[_constants.DIST_TAGS])) {
      this.logger.debug({
        name
      }, `changePackage bad data for @{name}`);
      return callback(_utils.ErrorCode.getBadData());
    }

    this.logger.debug({
      name
    }, `changePackage udapting package for @{name}`);

    this._updatePackage(name, (localData, cb) => {
      for (const version in localData.versions) {
        const incomingVersion = incomingPkg.versions[version];

        if (_lodash.default.isNil(incomingVersion)) {
          this.logger.info({
            name: name,
            version: version
          }, 'unpublishing @{name}@@{version}'); // FIXME: I prefer return a new object rather mutate the metadata

          delete localData.versions[version];
          delete localData.time[version];

          for (const file in localData._attachments) {
            if (localData._attachments[file].version === version) {
              delete localData._attachments[file].version;
            }
          }
        } else if (Object.prototype.hasOwnProperty.call(incomingVersion, 'deprecated')) {
          const incomingDeprecated = incomingVersion.deprecated;

          if (incomingDeprecated != localData.versions[version].deprecated) {
            if (!incomingDeprecated) {
              this.logger.info({
                name: name,
                version: version
              }, 'undeprecating @{name}@@{version}');
              delete localData.versions[version].deprecated;
            } else {
              this.logger.info({
                name: name,
                version: version
              }, 'deprecating @{name}@@{version}');
              localData.versions[version].deprecated = incomingDeprecated;
            }

            localData.time.modified = new Date().toISOString();
          }
        }
      }

      localData[_constants.USERS] = incomingPkg[_constants.USERS];
      localData[_constants.DIST_TAGS] = incomingPkg[_constants.DIST_TAGS];
      cb(null);
    }, function (err) {
      if (err) {
        return callback(err);
      }

      callback();
    });
  }
  /**
   * Remove a tarball.
   * @param {*} name
   * @param {*} filename
   * @param {*} revision
   * @param {*} callback
   */


  removeTarball(name, filename, revision, callback) {
    (0, _assert.default)((0, _utils.validateName)(filename));

    this._updatePackage(name, (data, cb) => {
      if (data._attachments[filename]) {
        delete data._attachments[filename];
        cb(null);
      } else {
        cb(this._getFileNotAvailable());
      }
    }, err => {
      if (err) {
        return callback(err);
      }

      const storage = this._getLocalStorage(name);

      if (storage) {
        storage.deletePackage(filename, callback);
      }
    });
  }
  /**
   * Add a tarball.
   * @param {String} name
   * @param {String} filename
   * @return {Stream}
   */


  addTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));
    let length = 0;
    const shaOneHash = (0, _cryptoUtils.createTarballHash)();
    const uploadStream = new _streams.UploadTarball({});
    const _transform = uploadStream._transform;

    const storage = this._getLocalStorage(name);

    uploadStream.abort = function () {};

    uploadStream.done = function () {};

    uploadStream._transform = function (data, ...args) {
      shaOneHash.update(data); // measure the length for validation reasons

      length += data.length;
      const appliedData = [data, ...args]; // FIXME: not sure about this approach, tsc complains
      // @ts-ignore

      _transform.apply(uploadStream, appliedData);
    };

    if (name === '__proto__') {
      process.nextTick(() => {
        uploadStream.emit('error', _utils.ErrorCode.getForbidden());
      });
      return uploadStream;
    }

    if (!storage) {
      process.nextTick(() => {
        uploadStream.emit('error', "can't upload this package");
      });
      return uploadStream;
    }

    const writeStream = storage.writeTarball(filename);
    writeStream.on('error', err => {
      // @ts-ignore
      if (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT) {
        uploadStream.emit('error', _utils.ErrorCode.getConflict());
        uploadStream.abort(); // @ts-ignore
      } else if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        // check if package exists to throw an appropriate message
        this.getPackageMetadata(name, function (_err, _res) {
          if (_err) {
            uploadStream.emit('error', _err);
          } else {
            uploadStream.emit('error', err);
          }
        });
      } else {
        uploadStream.emit('error', err);
      }
    });
    writeStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      uploadStream.emit('open');
    });
    writeStream.on('success', () => {
      this._updatePackage(name, function updater(data, cb) {
        data._attachments[filename] = {
          shasum: shaOneHash.digest('hex')
        };
        cb(null);
      }, function (err) {
        if (err) {
          uploadStream.emit('error', err);
        } else {
          uploadStream.emit('success');
        }
      });
    });

    uploadStream.abort = function () {
      writeStream.abort();
    };

    uploadStream.done = function () {
      if (!length) {
        uploadStream.emit('error', _utils.ErrorCode.getBadData('refusing to accept zero-length file'));
        writeStream.abort();
      } else {
        writeStream.done();
      }
    };

    uploadStream.pipe(writeStream);
    return uploadStream;
  }
  /**
   * Get a tarball.
   * @param {*} name
   * @param {*} filename
   * @return {ReadTarball}
   */


  getTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));

    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return this._createFailureStreamResponse();
    }

    return this._streamSuccessReadTarBall(storage, filename);
  }
  /**
   * Return a stream that emits a read failure.
   * @private
   * @return {ReadTarball}
   */


  _createFailureStreamResponse() {
    const stream = new _streams.ReadTarball({});
    process.nextTick(() => {
      stream.emit('error', this._getFileNotAvailable());
    });
    return stream;
  }
  /**
   * Return a stream that emits the tarball data
   * @param {Object} storage
   * @param {String} filename
   * @private
   * @return {ReadTarball}
   */


  _streamSuccessReadTarBall(storage, filename) {
    const stream = new _streams.ReadTarball({});
    const readTarballStream = storage.readTarball(filename);
    const e404 = _utils.ErrorCode.getNotFound;

    stream.abort = function () {
      if (_lodash.default.isNil(readTarballStream) === false) {
        readTarballStream.abort();
      }
    };

    readTarballStream.on('error', function (err) {
      // @ts-ignore
      if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        stream.emit('error', e404('no such file available'));
      } else {
        stream.emit('error', err);
      }
    });
    readTarballStream.on('content-length', function (content) {
      stream.emit('content-length', content);
    });
    readTarballStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      stream.emit('open');
      readTarballStream.pipe(stream);
    });
    return stream;
  }
  /**
   * Retrieve a package by name.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */


  getPackageMetadata(name, callback = () => {}) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    this._readPackage(name, storage, callback);
  }
  /**
   * Search a local package.
   * @param {*} startKey
   * @param {*} options
   * @return {Function}
   */


  search(startKey, options) {
    const stream = new _streams.ReadTarball({
      objectMode: true
    });

    this._searchEachPackage((item, cb) => {
      // @ts-ignore
      if (item.time > parseInt(startKey, 10)) {
        this.getPackageMetadata(item.name, (err, data) => {
          if (err) {
            return cb(err);
          } // @ts-ignore


          const time = new Date(item.time).toISOString();
          const result = (0, _storageUtils.prepareSearchPackage)(data, time);

          if (_lodash.default.isNil(result) === false) {
            stream.push(result);
          }

          cb(null);
        });
      } else {
        cb(null);
      }
    }, function onEnd(err) {
      if (err) {
        stream.emit('error', err);
        return;
      }

      stream.end();
    });

    return stream;
  }
  /**
   * Retrieve a wrapper that provide access to the package location.
   * @param {Object} pkgName package name.
   * @return {Object}
   */


  _getLocalStorage(pkgName) {
    return this.storagePlugin.getPackageStorage(pkgName);
  }
  /**
   * Read a json file from storage.
   * @param {Object} storage
   * @param {Function} callback
   */


  _readPackage(name, storage, callback) {
    storage.readPackage(name, (err, result) => {
      if (err) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils.ErrorCode.getNotFound());
        }

        return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
      }

      callback(err, (0, _storageUtils.normalizePackage)(result));
    });
  }
  /**
   * Walks through each package and calls `on_package` on them.
   * @param {*} onPackage
   * @param {*} onEnd
   */


  _searchEachPackage(onPackage, onEnd) {
    // save wait whether plugin still do not support search functionality
    if (_lodash.default.isNil(this.storagePlugin.search)) {
      this.logger.warn('plugin search not implemented yet');
      onEnd();
    } else {
      this.storagePlugin.search(onPackage, onEnd, _utils.validateName);
    }
  }
  /**
   * Retrieve either a previous created local package or a boilerplate.
   * @param {*} pkgName
   * @param {*} callback
   * @return {Function}
   */


  _readCreatePackage(pkgName, callback) {
    const storage = this._getLocalStorage(pkgName);

    if (_lodash.default.isNil(storage)) {
      this._createNewPackage(pkgName, callback);

      return;
    }

    storage.readPackage(pkgName, (err, data) => {
      // TODO: race condition
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          data = (0, _storageUtils.generatePackageTemplate)(pkgName);
        } else {
          return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
        }
      }

      callback(null, (0, _storageUtils.normalizePackage)(data));
    });
  }

  _createNewPackage(name, callback) {
    return callback(null, (0, _storageUtils.normalizePackage)((0, _storageUtils.generatePackageTemplate)(name)));
  }
  /**
   * Handle internal error
   * @param {*} err
   * @param {*} file
   * @param {*} message
   * @return {Object} Error instance
   */


  _internalError(err, file, message) {
    this.logger.error({
      err: err,
      file: file
    }, `${message}  @{file}: @{!err.message}`);
    return _utils.ErrorCode.getInternalError();
  }
  /**
   * @param {*} name package name
   * @param {*} updateHandler function(package, cb) - update function
   * @param {*} callback callback that gets invoked after it's all updated
   * @return {Function}
   */


  _updatePackage(name, updateHandler, callback) {
    const storage = this._getLocalStorage(name);

    if (!storage) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    storage.updatePackage(name, updateHandler, this._writePackage.bind(this), _storageUtils.normalizePackage, callback);
  }
  /**
   * Update the revision (_rev) string for a package.
   * @param {*} name
   * @param {*} json
   * @param {*} callback
   * @return {Function}
   */


  _writePackage(name, json, callback) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback();
    }

    storage.savePackage(name, this._setDefaultRevision(json), callback);
  }

  _setDefaultRevision(json) {
    // calculate revision from couch db
    if (_lodash.default.isString(json._rev) === false) {
      json._rev = _constants.STORAGE.DEFAULT_REVISION;
    } // this is intended in debug mode we do not want modify the store revision


    if (_lodash.default.isNil(this.config._debug)) {
      json._rev = (0, _storageUtils.generateRevision)(json._rev);
    }

    return json;
  }

  _deleteAttachments(storage, attachments, callback) {
    this.logger.debug({
      l: attachments.length
    }, `[storage/_deleteAttachments] delete attachments total: @{l}`);

    const unlinkNext = function (cb) {
      if (_lodash.default.isEmpty(attachments)) {
        return cb();
      }

      const attachment = attachments.shift();
      storage.deletePackage(attachment, function () {
        unlinkNext(cb);
      });
    };

    unlinkNext(function () {
      // try to unlink the directory, but ignore errors because it can fail
      storage.removePackage(function (err) {
        callback(err);
      });
    });
  }
  /**
   * Ensure the dist file remains as the same protocol
   * @param {Object} hash metadata
   * @param {String} upLinkKey registry key
   * @private
   */


  _updateUplinkToRemoteProtocol(hash, upLinkKey) {
    // if we got this information from a known registry,
    // use the same protocol for the tarball
    //
    // see https://github.com/rlidwka/sinopia/issues/166
    const tarballUrl = _url.default.parse(hash.url);

    const uplinkUrl = _url.default.parse(this.config.uplinks[upLinkKey].url);

    if (uplinkUrl.host === tarballUrl.host) {
      tarballUrl.protocol = uplinkUrl.protocol;
      hash.registry = upLinkKey;
      hash.url = _url.default.format(tarballUrl);
    }
  }

  async getSecret(config) {
    const secretKey = await this.storagePlugin.getSecret();
    return this.storagePlugin.setSecret(config.checkSecretKey(secretKey));
  }

  _loadStorage(config, logger) {
    const Storage = this._loadStorePlugin();

    if (_lodash.default.isNil(Storage)) {
      (0, _assert.default)(this.config.storage, 'CONFIG: storage path not defined');
      return new _localStorage.default(this.config, logger);
    }

    return Storage;
  }

  _loadStorePlugin() {
    const plugin_params = {
      config: this.config,
      logger: this.logger
    }; // eslint-disable-next-line max-len

    const plugins = (0, _pluginLoader.default)(this.config, this.config.store, plugin_params, plugin => {
      return plugin.getPackageStorage;
    });
    return _lodash.default.head(plugins);
  }

  saveToken(token) {
    if (_lodash.default.isFunction(this.storagePlugin.saveToken) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.saveToken(token);
  }

  deleteToken(user, tokenKey) {
    if (_lodash.default.isFunction(this.storagePlugin.deleteToken) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.deleteToken(user, tokenKey);
  }

  readTokens(filter) {
    if (_lodash.default.isFunction(this.storagePlugin.readTokens) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.readTokens(filter);
  }

}

var _default = LocalStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbG9jYWwtc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJMb2NhbFN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImxvZ2dlciIsImNoaWxkIiwic3ViIiwic3RvcmFnZVBsdWdpbiIsIl9sb2FkU3RvcmFnZSIsImFkZFBhY2thZ2UiLCJuYW1lIiwicGtnIiwiY2FsbGJhY2siLCJzdG9yYWdlIiwiX2dldExvY2FsU3RvcmFnZSIsIl8iLCJpc05pbCIsIkVycm9yQ29kZSIsImdldE5vdEZvdW5kIiwiY3JlYXRlUGFja2FnZSIsImVyciIsImlzTnVsbCIsImNvZGUiLCJTVE9SQUdFIiwiRklMRV9FWElTVF9FUlJPUiIsIkhUVFBfU1RBVFVTIiwiQ09ORkxJQ1QiLCJnZXRDb25mbGljdCIsImxhdGVzdCIsInZlcnNpb25zIiwicmVtb3ZlUGFja2FnZSIsImRlYnVnIiwicmVhZFBhY2thZ2UiLCJkYXRhIiwiTk9fU1VDSF9GSUxFX0VSUk9SIiwiTk9UX0ZPVU5EIiwicmVtb3ZlIiwicmVtb3ZlRmFpbGVkIiwiZ2V0QmFkRGF0YSIsIm1lc3NhZ2UiLCJkZWxldGVQYWNrYWdlIiwiUEFDS0FHRV9GSUxFX05BTUUiLCJhdHRhY2htZW50cyIsIk9iamVjdCIsImtleXMiLCJfYXR0YWNobWVudHMiLCJfZGVsZXRlQXR0YWNobWVudHMiLCJ1cGRhdGVWZXJzaW9ucyIsInBhY2thZ2VJbmZvIiwiX3JlYWRDcmVhdGVQYWNrYWdlIiwicGFja2FnZUxvY2FsSnNvbiIsImNoYW5nZSIsInJlYWRtZSIsInZlcnNpb25JZCIsInZlcnNpb24iLCJjb250cmlidXRvcnMiLCJkaXN0IiwidGFyYmFsbCIsInVybE9iamVjdCIsIlVybE5vZGUiLCJwYXJzZSIsImZpbGVuYW1lIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiX2Rpc3RmaWxlcyIsImhhc2giLCJ1cmwiLCJzaGEiLCJzaGFzdW0iLCJ1cExpbmsiLCJTeW1ib2wiLCJmb3IiLCJfdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbCIsInRhZyIsIkRJU1RfVEFHUyIsInVwIiwiX3VwbGlua3MiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuZWVkX2NoYW5nZSIsImV0YWciLCJmZXRjaGVkIiwiaXNFcXVhbCIsInRpbWUiLCJfd3JpdGVQYWNrYWdlIiwiYWRkVmVyc2lvbiIsIm1ldGFkYXRhIiwiX3VwZGF0ZVBhY2thZ2UiLCJjYiIsImhhc1ZlcnNpb24iLCJpc1N0cmluZyIsImVycm9yTWVzc2FnZSIsImdldEJhZFJlcXVlc3QiLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNyZWF0ZWQiLCJhZGQiLCJhZGRGYWlsZWQiLCJtZXJnZVRhZ3MiLCJwa2dOYW1lIiwidGFncyIsIl9nZXRWZXJzaW9uTm90Rm91bmQiLCJBUElfRVJST1IiLCJWRVJTSU9OX05PVF9FWElTVCIsIl9nZXRGaWxlTm90QXZhaWxhYmxlIiwiY2hhbmdlUGFja2FnZSIsImluY29taW5nUGtnIiwicmV2aXNpb24iLCJsb2NhbERhdGEiLCJpbmNvbWluZ1ZlcnNpb24iLCJpbmZvIiwiZmlsZSIsImluY29taW5nRGVwcmVjYXRlZCIsImRlcHJlY2F0ZWQiLCJtb2RpZmllZCIsIlVTRVJTIiwicmVtb3ZlVGFyYmFsbCIsImFkZFRhcmJhbGwiLCJsZW5ndGgiLCJzaGFPbmVIYXNoIiwidXBsb2FkU3RyZWFtIiwiVXBsb2FkVGFyYmFsbCIsIl90cmFuc2Zvcm0iLCJhYm9ydCIsImRvbmUiLCJhcmdzIiwidXBkYXRlIiwiYXBwbGllZERhdGEiLCJhcHBseSIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXQiLCJnZXRGb3JiaWRkZW4iLCJ3cml0ZVN0cmVhbSIsIndyaXRlVGFyYmFsbCIsIm9uIiwiZ2V0UGFja2FnZU1ldGFkYXRhIiwiX2VyciIsIl9yZXMiLCJ1cGRhdGVyIiwiZGlnZXN0IiwicGlwZSIsImdldFRhcmJhbGwiLCJfY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlIiwiX3N0cmVhbVN1Y2Nlc3NSZWFkVGFyQmFsbCIsInN0cmVhbSIsIlJlYWRUYXJiYWxsIiwicmVhZFRhcmJhbGxTdHJlYW0iLCJyZWFkVGFyYmFsbCIsImU0MDQiLCJjb250ZW50IiwiX3JlYWRQYWNrYWdlIiwic2VhcmNoIiwic3RhcnRLZXkiLCJvcHRpb25zIiwib2JqZWN0TW9kZSIsIl9zZWFyY2hFYWNoUGFja2FnZSIsIml0ZW0iLCJwYXJzZUludCIsInJlc3VsdCIsInB1c2giLCJvbkVuZCIsImVuZCIsImdldFBhY2thZ2VTdG9yYWdlIiwiX2ludGVybmFsRXJyb3IiLCJvblBhY2thZ2UiLCJ3YXJuIiwidmFsaWRhdGVOYW1lIiwiX2NyZWF0ZU5ld1BhY2thZ2UiLCJlcnJvciIsImdldEludGVybmFsRXJyb3IiLCJ1cGRhdGVIYW5kbGVyIiwidXBkYXRlUGFja2FnZSIsImJpbmQiLCJub3JtYWxpemVQYWNrYWdlIiwianNvbiIsInNhdmVQYWNrYWdlIiwiX3NldERlZmF1bHRSZXZpc2lvbiIsIl9yZXYiLCJERUZBVUxUX1JFVklTSU9OIiwiX2RlYnVnIiwibCIsInVubGlua05leHQiLCJpc0VtcHR5IiwiYXR0YWNobWVudCIsInNoaWZ0IiwidXBMaW5rS2V5IiwidGFyYmFsbFVybCIsInVwbGlua1VybCIsInVwbGlua3MiLCJob3N0IiwicHJvdG9jb2wiLCJyZWdpc3RyeSIsImZvcm1hdCIsImdldFNlY3JldCIsInNlY3JldEtleSIsInNldFNlY3JldCIsImNoZWNrU2VjcmV0S2V5IiwiU3RvcmFnZSIsIl9sb2FkU3RvcmVQbHVnaW4iLCJMb2NhbERhdGFiYXNlIiwicGx1Z2luX3BhcmFtcyIsInBsdWdpbnMiLCJzdG9yZSIsInBsdWdpbiIsImhlYWQiLCJzYXZlVG9rZW4iLCJ0b2tlbiIsImlzRnVuY3Rpb24iLCJQcm9taXNlIiwicmVqZWN0IiwiZ2V0Q29kZSIsIlNFUlZJQ0VfVU5BVkFJTEFCTEUiLCJTVVBQT1JUX0VSUk9SUyIsIlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSIsImRlbGV0ZVRva2VuIiwidXNl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YUFBTCxDQUFtQnlNLFNBQWhDLE1BQStDLEtBQW5ELEVBQTBEO0FBQ3hELGFBQU9HLE9BQU8sQ0FBQ0MsTUFBUixDQUNMbk0saUJBQVVvTSxPQUFWLENBQWtCNUwsdUJBQVk2TCxtQkFBOUIsRUFBbURDLDBCQUFlQyx3QkFBbEUsQ0FESyxDQUFQO0FBR0Q7O0FBRUQsV0FBTyxLQUFLak4sYUFBTCxDQUFtQnlNLFNBQW5CLENBQTZCQyxLQUE3QixDQUFQO0FBQ0Q7O0FBRU1RLEVBQUFBLFdBQVcsQ0FBQ0MsSUFBRCxFQUFlQyxRQUFmLEVBQStDO0FBQy9ELFFBQUk1TSxnQkFBRW1NLFVBQUYsQ0FBYSxLQUFLM00sYUFBTCxDQUFtQmtOLFdBQWhDLE1BQWlELEtBQXJELEVBQTREO0FBQzFELGFBQU9OLE9BQU8sQ0FBQ0MsTUFBUixDQUNMbk0saUJBQVVvTSxPQUFWLENBQWtCNUwsdUJBQVk2TCxtQkFBOUIsRUFBbURDLDBCQUFlQyx3QkFBbEUsQ0FESyxDQUFQO0FBR0Q7O0FBRUQsV0FBTyxLQUFLak4sYUFBTCxDQUFtQmtOLFdBQW5CLENBQStCQyxJQUEvQixFQUFxQ0MsUUFBckMsQ0FBUDtBQUNEOztBQUVNQyxFQUFBQSxVQUFVLENBQUNDLE1BQUQsRUFBd0M7QUFDdkQsUUFBSTlNLGdCQUFFbU0sVUFBRixDQUFhLEtBQUszTSxhQUFMLENBQW1CcU4sVUFBaEMsTUFBZ0QsS0FBcEQsRUFBMkQ7QUFDekQsYUFBT1QsT0FBTyxDQUFDQyxNQUFSLENBQ0xuTSxpQkFBVW9NLE9BQVYsQ0FBa0I1TCx1QkFBWTZMLG1CQUE5QixFQUFtREMsMEJBQWVDLHdCQUFsRSxDQURLLENBQVA7QUFHRDs7QUFFRCxXQUFPLEtBQUtqTixhQUFMLENBQW1CcU4sVUFBbkIsQ0FBOEJDLE1BQTlCLENBQVA7QUFDRDs7QUEvM0JvQzs7ZUFrNEJ4QjVOLFkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgVXJsTm9kZSBmcm9tICd1cmwnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMb2NhbERhdGFiYXNlIGZyb20gJ0B2ZXJkYWNjaW8vbG9jYWwtc3RvcmFnZSc7XG5pbXBvcnQgeyBVcGxvYWRUYXJiYWxsLCBSZWFkVGFyYmFsbCB9IGZyb20gJ0B2ZXJkYWNjaW8vc3RyZWFtcyc7XG5pbXBvcnQge1xuICBUb2tlbixcbiAgVG9rZW5GaWx0ZXIsXG4gIFBhY2thZ2UsXG4gIENvbmZpZyxcbiAgSVVwbG9hZFRhcmJhbGwsXG4gIElSZWFkVGFyYmFsbCxcbiAgTWVyZ2VUYWdzLFxuICBWZXJzaW9uLFxuICBEaXN0RmlsZSxcbiAgQ2FsbGJhY2ssXG4gIExvZ2dlcixcbiAgSVBsdWdpblN0b3JhZ2UsXG4gIElQYWNrYWdlU3RvcmFnZSxcbiAgQXV0aG9yLFxuICBDYWxsYmFja0FjdGlvbixcbiAgb25TZWFyY2hQYWNrYWdlLFxuICBvbkVuZFNlYXJjaFBhY2thZ2UsXG4gIFN0b3JhZ2VVcGRhdGVDYWxsYmFja1xufSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcbmltcG9ydCB7IFZlcmRhY2Npb0Vycm9yIH0gZnJvbSAnQHZlcmRhY2Npby9jb21tb25zLWFwaSc7XG5pbXBvcnQgbG9hZFBsdWdpbiBmcm9tICcuLi9saWIvcGx1Z2luLWxvYWRlcic7XG5pbXBvcnQgeyBJU3RvcmFnZSwgU3RyaW5nVmFsdWUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGlzT2JqZWN0LCBnZXRMYXRlc3RWZXJzaW9uLCB0YWdWZXJzaW9uLCB2YWxpZGF0ZU5hbWUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7XG4gIGdlbmVyYXRlUGFja2FnZVRlbXBsYXRlLFxuICBub3JtYWxpemVQYWNrYWdlLFxuICBnZW5lcmF0ZVJldmlzaW9uLFxuICBnZXRMYXRlc3RSZWFkbWUsXG4gIGNsZWFuVXBSZWFkbWUsXG4gIG5vcm1hbGl6ZUNvbnRyaWJ1dG9yc1xufSBmcm9tICcuL3N0b3JhZ2UtdXRpbHMnO1xuaW1wb3J0IHsgQVBJX0VSUk9SLCBESVNUX1RBR1MsIEhUVFBfU1RBVFVTLCBTVE9SQUdFLCBTVVBQT1JUX0VSUk9SUywgVVNFUlMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVUYXJiYWxsSGFzaCB9IGZyb20gJy4vY3J5cHRvLXV0aWxzJztcbmltcG9ydCB7IHByZXBhcmVTZWFyY2hQYWNrYWdlIH0gZnJvbSAnLi9zdG9yYWdlLXV0aWxzJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFN0b3JhZ2UgaW50ZXJmYWNlIChzYW1lIGZvciBzdG9yYWdlLmpzLCBsb2NhbC1zdG9yYWdlLmpzLCB1cC1zdG9yYWdlLmpzKS5cbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlIGltcGxlbWVudHMgSVN0b3JhZ2Uge1xuICBwdWJsaWMgY29uZmlnOiBDb25maWc7XG4gIHB1YmxpYyBzdG9yYWdlUGx1Z2luOiBJUGx1Z2luU3RvcmFnZTxDb25maWc+O1xuICBwdWJsaWMgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29uZmlnLCBsb2dnZXI6IExvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLmNoaWxkKHsgc3ViOiAnZnMnIH0pO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc3RvcmFnZVBsdWdpbiA9IHRoaXMuX2xvYWRTdG9yYWdlKGNvbmZpZywgbG9nZ2VyKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRQYWNrYWdlKG5hbWU6IHN0cmluZywgcGtnOiBQYWNrYWdlLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBzdG9yYWdlOiBhbnkgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG5cbiAgICBpZiAoXy5pc05pbChzdG9yYWdlKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgndGhpcyBwYWNrYWdlIGNhbm5vdCBiZSBhZGRlZCcpKTtcbiAgICB9XG5cbiAgICBzdG9yYWdlLmNyZWF0ZVBhY2thZ2UobmFtZSwgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUobmFtZSksIChlcnIpID0+IHtcbiAgICAgIC8vIEZJWE1FOiBpdCB3aWxsIGJlIGZpeGVkIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmRhY2Npby92ZXJkYWNjaW8vcHVsbC8xMzYwXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoXG4gICAgICAgIF8uaXNOdWxsKGVycikgPT09IGZhbHNlICYmXG4gICAgICAgIChlcnIuY29kZSA9PT0gU1RPUkFHRS5GSUxFX0VYSVNUX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5DT05GTElDVClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldENvbmZsaWN0KCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXRlc3QgPSBnZXRMYXRlc3RWZXJzaW9uKHBrZyk7XG4gICAgICBpZiAoXy5pc05pbChsYXRlc3QpID09PSBmYWxzZSAmJiBwa2cudmVyc2lvbnNbbGF0ZXN0XSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcGtnLnZlcnNpb25zW2xhdGVzdF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgcGFja2FnZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlUGFja2FnZShuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IGFueSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1Zyh7IG5hbWUgfSwgYFtzdG9yYWdlXSByZW1vdmluZyBwYWNrYWdlIEB7bmFtZX1gKTtcblxuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UucmVhZFBhY2thZ2UobmFtZSwgKGVyciwgZGF0YTogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IG5vcm1hbGl6ZVBhY2thZ2UoZGF0YSk7XG5cbiAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5yZW1vdmUobmFtZSwgKHJlbW92ZUZhaWxlZDogRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHJlbW92ZUZhaWxlZCkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBkYXRhYmFzZSBpcyBsb2NrZWRcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIHsgbmFtZSB9LFxuICAgICAgICAgICAgYFtzdG9yYWdlL3JlbW92ZVBhY2thZ2VdIHRoZSBkYXRhYmFzZSBpcyBsb2NrZWQsIHJlbW92ZWQgaGFzIGZhaWxlZCBmb3IgQHtuYW1lfWBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXRCYWREYXRhKHJlbW92ZUZhaWxlZC5tZXNzYWdlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdG9yYWdlLmRlbGV0ZVBhY2thZ2UoU1RPUkFHRS5QQUNLQUdFX0ZJTEVfTkFNRSwgKGVycik6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdHRhY2htZW50cyA9IE9iamVjdC5rZXlzKGRhdGEuX2F0dGFjaG1lbnRzKTtcblxuICAgICAgICAgIHRoaXMuX2RlbGV0ZUF0dGFjaG1lbnRzKHN0b3JhZ2UsIGF0dGFjaG1lbnRzLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25pemUgcmVtb3RlIHBhY2thZ2UgaW5mbyB3aXRoIHRoZSBsb2NhbCBvbmVcbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gcGFja2FnZUluZm9cbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIHVwZGF0ZVZlcnNpb25zKG5hbWU6IHN0cmluZywgcGFja2FnZUluZm86IFBhY2thZ2UsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX3JlYWRDcmVhdGVQYWNrYWdlKG5hbWUsIChlcnIsIHBhY2thZ2VMb2NhbEpzb24pOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgIC8vIHVwZGF0aW5nIHJlYWRtZVxuICAgICAgcGFja2FnZUxvY2FsSnNvbi5yZWFkbWUgPSBnZXRMYXRlc3RSZWFkbWUocGFja2FnZUluZm8pO1xuICAgICAgaWYgKHBhY2thZ2VJbmZvLnJlYWRtZSAhPT0gcGFja2FnZUxvY2FsSnNvbi5yZWFkbWUpIHtcbiAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmVyc2lvbklkIGluIHBhY2thZ2VJbmZvLnZlcnNpb25zKSB7XG4gICAgICAgIGlmIChfLmlzTmlsKHBhY2thZ2VMb2NhbEpzb24udmVyc2lvbnNbdmVyc2lvbklkXSkpIHtcbiAgICAgICAgICBsZXQgdmVyc2lvbiA9IHBhY2thZ2VJbmZvLnZlcnNpb25zW3ZlcnNpb25JZF07XG5cbiAgICAgICAgICAvLyB3ZSBkb24ndCBrZWVwIHJlYWRtZSBmb3IgcGFja2FnZSB2ZXJzaW9ucyxcbiAgICAgICAgICAvLyBvbmx5IG9uZSByZWFkbWUgcGVyIHBhY2thZ2VcbiAgICAgICAgICB2ZXJzaW9uID0gY2xlYW5VcFJlYWRtZSh2ZXJzaW9uKTtcbiAgICAgICAgICB2ZXJzaW9uLmNvbnRyaWJ1dG9ycyA9IG5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyh2ZXJzaW9uLmNvbnRyaWJ1dG9ycyBhcyBBdXRob3JbXSk7XG5cbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb24udmVyc2lvbnNbdmVyc2lvbklkXSA9IHZlcnNpb247XG5cbiAgICAgICAgICBpZiAodmVyc2lvbi5kaXN0ICYmIHZlcnNpb24uZGlzdC50YXJiYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB1cmxPYmplY3Q6IGFueSA9IFVybE5vZGUucGFyc2UodmVyc2lvbi5kaXN0LnRhcmJhbGwpO1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvXi4qXFwvLywgJycpO1xuXG4gICAgICAgICAgICAvLyB3ZSBkbyBOT1Qgb3ZlcndyaXRlIGFueSBleGlzdGluZyByZWNvcmRzXG4gICAgICAgICAgICBpZiAoXy5pc05pbChwYWNrYWdlTG9jYWxKc29uLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKSkge1xuICAgICAgICAgICAgICBjb25zdCBoYXNoOiBEaXN0RmlsZSA9IChwYWNrYWdlTG9jYWxKc29uLl9kaXN0ZmlsZXNbZmlsZW5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHVybDogdmVyc2lvbi5kaXN0LnRhcmJhbGwsXG4gICAgICAgICAgICAgICAgc2hhOiB2ZXJzaW9uLmRpc3Quc2hhc3VtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvKiBlc2xpbnQgc3BhY2VkLWNvbW1lbnQ6IDAgKi9cbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgICAgICBjb25zdCB1cExpbms6IHN0cmluZyA9IHZlcnNpb25bU3ltYm9sLmZvcignX192ZXJkYWNjaW9fdXBsaW5rJyldO1xuXG4gICAgICAgICAgICAgIGlmIChfLmlzTmlsKHVwTGluaykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbChoYXNoLCB1cExpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdGFnIGluIHBhY2thZ2VJbmZvW0RJU1RfVEFHU10pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFwYWNrYWdlTG9jYWxKc29uW0RJU1RfVEFHU11bdGFnXSB8fFxuICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb25bRElTVF9UQUdTXVt0YWddICE9PSBwYWNrYWdlSW5mb1tESVNUX1RBR1NdW3RhZ11cbiAgICAgICAgKSB7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICBwYWNrYWdlTG9jYWxKc29uW0RJU1RfVEFHU11bdGFnXSA9IHBhY2thZ2VJbmZvW0RJU1RfVEFHU11bdGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHVwIGluIHBhY2thZ2VJbmZvLl91cGxpbmtzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZUluZm8uX3VwbGlua3MsIHVwKSkge1xuICAgICAgICAgIGNvbnN0IG5lZWRfY2hhbmdlID1cbiAgICAgICAgICAgICFpc09iamVjdChwYWNrYWdlTG9jYWxKc29uLl91cGxpbmtzW3VwXSkgfHxcbiAgICAgICAgICAgIHBhY2thZ2VJbmZvLl91cGxpbmtzW3VwXS5ldGFnICE9PSBwYWNrYWdlTG9jYWxKc29uLl91cGxpbmtzW3VwXS5ldGFnIHx8XG4gICAgICAgICAgICBwYWNrYWdlSW5mby5fdXBsaW5rc1t1cF0uZmV0Y2hlZCAhPT0gcGFja2FnZUxvY2FsSnNvbi5fdXBsaW5rc1t1cF0uZmV0Y2hlZDtcblxuICAgICAgICAgIGlmIChuZWVkX2NoYW5nZSkge1xuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb24uX3VwbGlua3NbdXBdID0gcGFja2FnZUluZm8uX3VwbGlua3NbdXBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3RpbWUnIGluIHBhY2thZ2VJbmZvICYmICFfLmlzRXF1YWwocGFja2FnZUxvY2FsSnNvbi50aW1lLCBwYWNrYWdlSW5mby50aW1lKSkge1xuICAgICAgICBwYWNrYWdlTG9jYWxKc29uLnRpbWUgPSBwYWNrYWdlSW5mby50aW1lO1xuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKHsgbmFtZSB9LCAndXBkYXRpbmcgcGFja2FnZSBAe25hbWV9IGluZm8nKTtcbiAgICAgICAgdGhpcy5fd3JpdGVQYWNrYWdlKG5hbWUsIHBhY2thZ2VMb2NhbEpzb24sIGZ1bmN0aW9uIChlcnIpOiB2b2lkIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHBhY2thZ2VMb2NhbEpzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHBhY2thZ2VMb2NhbEpzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB2ZXJzaW9uIHRvIGEgcHJldmlvdXMgbG9jYWwgcGFja2FnZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmVyc2lvblxuICAgKiBAcGFyYW0geyp9IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Kn0gdGFnXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBhZGRWZXJzaW9uKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgbWV0YWRhdGE6IFZlcnNpb24sXG4gICAgdGFnOiBTdHJpbmdWYWx1ZSxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tBY3Rpb25cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgIG5hbWUsXG4gICAgICAoZGF0YSwgY2I6IENhbGxiYWNrKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIGtlZXAgb25seSBvbmUgcmVhZG1lIHBlciBwYWNrYWdlXG4gICAgICAgIGRhdGEucmVhZG1lID0gbWV0YWRhdGEucmVhZG1lO1xuXG4gICAgICAgIC8vIFRPRE86IGxvZGFzaCByZW1vdmVcbiAgICAgICAgbWV0YWRhdGEgPSBjbGVhblVwUmVhZG1lKG1ldGFkYXRhKTtcbiAgICAgICAgbWV0YWRhdGEuY29udHJpYnV0b3JzID0gbm9ybWFsaXplQ29udHJpYnV0b3JzKG1ldGFkYXRhLmNvbnRyaWJ1dG9ycyBhcyBBdXRob3JbXSk7XG5cbiAgICAgICAgY29uc3QgaGFzVmVyc2lvbiA9IGRhdGEudmVyc2lvbnNbdmVyc2lvbl0gIT0gbnVsbDtcbiAgICAgICAgaWYgKGhhc1ZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2IoRXJyb3JDb2RlLmdldENvbmZsaWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdXBsb2FkZWQgdGFyYmFsbCBoYXMgYSBkaWZmZXJlbnQgc2hhc3VtLCBpdCdzIHZlcnkgbGlrZWx5IHRoYXQgd2UgaGF2ZSBzb21lIGtpbmQgb2YgZXJyb3JcbiAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhLmRpc3QpICYmIF8uaXNTdHJpbmcobWV0YWRhdGEuZGlzdC50YXJiYWxsKSkge1xuICAgICAgICAgIGNvbnN0IHRhcmJhbGwgPSBtZXRhZGF0YS5kaXN0LnRhcmJhbGwucmVwbGFjZSgvLipcXC8vLCAnJyk7XG5cbiAgICAgICAgICBpZiAoaXNPYmplY3QoZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0pKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIF8uaXNOaWwoZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0uc2hhc3VtKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgXy5pc05pbChtZXRhZGF0YS5kaXN0LnNoYXN1bSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuX2F0dGFjaG1lbnRzW3RhcmJhbGxdLnNoYXN1bSAhPSBtZXRhZGF0YS5kaXN0LnNoYXN1bSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBzaGFzdW0gZXJyb3IsICR7ZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0uc2hhc3VtfSAhPSAke21ldGFkYXRhLmRpc3Quc2hhc3VtfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKEVycm9yQ29kZS5nZXRCYWRSZXF1ZXN0KGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBzb21lIG9sZCBzdG9yYWdlIGRvIG5vdCBoYXZlIHRoaXMgZmllbGQgIzc0MFxuICAgICAgICAgICAgaWYgKF8uaXNOaWwoZGF0YS50aW1lKSkge1xuICAgICAgICAgICAgICBkYXRhLnRpbWUgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YS50aW1lWydtb2RpZmllZCddID0gY3VycmVudERhdGU7XG5cbiAgICAgICAgICAgIGlmICgnY3JlYXRlZCcgaW4gZGF0YS50aW1lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBkYXRhLnRpbWUuY3JlYXRlZCA9IGN1cnJlbnREYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLnRpbWVbdmVyc2lvbl0gPSBjdXJyZW50RGF0ZTtcbiAgICAgICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzW3RhcmJhbGxdLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudmVyc2lvbnNbdmVyc2lvbl0gPSBtZXRhZGF0YTtcbiAgICAgICAgdGFnVmVyc2lvbihkYXRhLCB2ZXJzaW9uLCB0YWcpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5hZGQobmFtZSwgKGFkZEZhaWxlZCk6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChhZGRGYWlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihFcnJvckNvZGUuZ2V0QmFkRGF0YShhZGRGYWlsZWQubWVzc2FnZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhIG5ldyBsaXN0IG9mIHRhZ3MgZm9yIGEgbG9jYWwgcGFja2FnZXMgd2l0aCB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKiBAcGFyYW0geyp9IHBrZ05hbWVcbiAgICogQHBhcmFtIHsqfSB0YWdzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBtZXJnZVRhZ3MocGtnTmFtZTogc3RyaW5nLCB0YWdzOiBNZXJnZVRhZ3MsIGNhbGxiYWNrOiBDYWxsYmFja0FjdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3VwZGF0ZVBhY2thZ2UoXG4gICAgICBwa2dOYW1lLFxuICAgICAgKGRhdGEsIGNiKTogdm9pZCA9PiB7XG4gICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGFncykge1xuICAgICAgICAgIC8vIHRoaXMgaGFuZGxlIGRpc3QtdGFnIHJtIGNvbW1hbmRcbiAgICAgICAgICBpZiAoXy5pc051bGwodGFnc1t0YWddKSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbRElTVF9UQUdTXVt0YWddO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF8uaXNOaWwoZGF0YS52ZXJzaW9uc1t0YWdzW3RhZ11dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKHRoaXMuX2dldFZlcnNpb25Ob3RGb3VuZCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmVyc2lvbjogc3RyaW5nID0gdGFnc1t0YWddO1xuICAgICAgICAgIHRhZ1ZlcnNpb24oZGF0YSwgdmVyc2lvbiwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHZlcnNpb24gbm90IGZvdW5kXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX2dldFZlcnNpb25Ob3RGb3VuZCgpOiBWZXJkYWNjaW9FcnJvciB7XG4gICAgcmV0dXJuIEVycm9yQ29kZS5nZXROb3RGb3VuZChBUElfRVJST1IuVkVSU0lPTl9OT1RfRVhJU1QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBmaWxlIG5vIGF2YWlsYWJsZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9nZXRGaWxlTm90QXZhaWxhYmxlKCk6IFZlcmRhY2Npb0Vycm9yIHtcbiAgICByZXR1cm4gRXJyb3JDb2RlLmdldE5vdEZvdW5kKCdubyBzdWNoIGZpbGUgYXZhaWxhYmxlJyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwYWNrYWdlIG1ldGFkYXRhLCB0YWdzIGFuZCBhdHRhY2htZW50cyAodGFyYmFsbHMpLlxuICAgKiBOb3RlOiBDdXJyZW50bHkgc3VwcG9ydHMgdW5wdWJsaXNoaW5nIGFuZCBkZXByZWNhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gaW5jb21pbmdQa2dcbiAgICogQHBhcmFtIHsqfSByZXZpc2lvblxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHVibGljIGNoYW5nZVBhY2thZ2UoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGluY29taW5nUGtnOiBQYWNrYWdlLFxuICAgIHJldmlzaW9uOiBzdHJpbmcgfCB2b2lkLFxuICAgIGNhbGxiYWNrOiBDYWxsYmFja1xuICApOiB2b2lkIHtcbiAgICBpZiAoIWlzT2JqZWN0KGluY29taW5nUGtnLnZlcnNpb25zKSB8fCAhaXNPYmplY3QoaW5jb21pbmdQa2dbRElTVF9UQUdTXSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKHsgbmFtZSB9LCBgY2hhbmdlUGFja2FnZSBiYWQgZGF0YSBmb3IgQHtuYW1lfWApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXRCYWREYXRhKCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKHsgbmFtZSB9LCBgY2hhbmdlUGFja2FnZSB1ZGFwdGluZyBwYWNrYWdlIGZvciBAe25hbWV9YCk7XG4gICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgIG5hbWUsXG4gICAgICAobG9jYWxEYXRhOiBQYWNrYWdlLCBjYjogQ2FsbGJhY2tBY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB2ZXJzaW9uIGluIGxvY2FsRGF0YS52ZXJzaW9ucykge1xuICAgICAgICAgIGNvbnN0IGluY29taW5nVmVyc2lvbiA9IGluY29taW5nUGtnLnZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgIGlmIChfLmlzTmlsKGluY29taW5nVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oeyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH0sICd1bnB1Ymxpc2hpbmcgQHtuYW1lfUBAe3ZlcnNpb259Jyk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBJIHByZWZlciByZXR1cm4gYSBuZXcgb2JqZWN0IHJhdGhlciBtdXRhdGUgdGhlIG1ldGFkYXRhXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxEYXRhLnZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsRGF0YS50aW1lIVt2ZXJzaW9uXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIGluIGxvY2FsRGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsRGF0YS5fYXR0YWNobWVudHNbZmlsZV0udmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbERhdGEuX2F0dGFjaG1lbnRzW2ZpbGVdLnZlcnNpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNvbWluZ1ZlcnNpb24sICdkZXByZWNhdGVkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluY29taW5nRGVwcmVjYXRlZCA9IGluY29taW5nVmVyc2lvbi5kZXByZWNhdGVkO1xuICAgICAgICAgICAgaWYgKGluY29taW5nRGVwcmVjYXRlZCAhPSBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl0uZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoIWluY29taW5nRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICB7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24gfSxcbiAgICAgICAgICAgICAgICAgICd1bmRlcHJlY2F0aW5nIEB7bmFtZX1AQHt2ZXJzaW9ufSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl0uZGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgeyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH0sXG4gICAgICAgICAgICAgICAgICAnZGVwcmVjYXRpbmcgQHtuYW1lfUBAe3ZlcnNpb259J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9jYWxEYXRhLnZlcnNpb25zW3ZlcnNpb25dLmRlcHJlY2F0ZWQgPSBpbmNvbWluZ0RlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9jYWxEYXRhLnRpbWUhLm1vZGlmaWVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRGF0YVtVU0VSU10gPSBpbmNvbWluZ1BrZ1tVU0VSU107XG4gICAgICAgIGxvY2FsRGF0YVtESVNUX1RBR1NdID0gaW5jb21pbmdQa2dbRElTVF9UQUdTXTtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YXJiYWxsLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBmaWxlbmFtZVxuICAgKiBAcGFyYW0geyp9IHJldmlzaW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyByZW1vdmVUYXJiYWxsKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmaWxlbmFtZTogc3RyaW5nLFxuICAgIHJldmlzaW9uOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrQWN0aW9uXG4gICk6IHZvaWQge1xuICAgIGFzc2VydCh2YWxpZGF0ZU5hbWUoZmlsZW5hbWUpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBhY2thZ2UoXG4gICAgICBuYW1lLFxuICAgICAgKGRhdGEsIGNiKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChkYXRhLl9hdHRhY2htZW50c1tmaWxlbmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdO1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKHRoaXMuX2dldEZpbGVOb3RBdmFpbGFibGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXJyOiBWZXJkYWNjaW9FcnJvcik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICAgIHN0b3JhZ2UuZGVsZXRlUGFja2FnZShmaWxlbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YXJiYWxsLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgcHVibGljIGFkZFRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogSVVwbG9hZFRhcmJhbGwge1xuICAgIGFzc2VydCh2YWxpZGF0ZU5hbWUoZmlsZW5hbWUpKTtcblxuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGNvbnN0IHNoYU9uZUhhc2ggPSBjcmVhdGVUYXJiYWxsSGFzaCgpO1xuICAgIGNvbnN0IHVwbG9hZFN0cmVhbTogSVVwbG9hZFRhcmJhbGwgPSBuZXcgVXBsb2FkVGFyYmFsbCh7fSk7XG4gICAgY29uc3QgX3RyYW5zZm9ybSA9IHVwbG9hZFN0cmVhbS5fdHJhbnNmb3JtO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG5cbiAgICB1cGxvYWRTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7fTtcbiAgICB1cGxvYWRTdHJlYW0uZG9uZSA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuXG4gICAgdXBsb2FkU3RyZWFtLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgLi4uYXJncyk6IHZvaWQge1xuICAgICAgc2hhT25lSGFzaC51cGRhdGUoZGF0YSk7XG4gICAgICAvLyBtZWFzdXJlIHRoZSBsZW5ndGggZm9yIHZhbGlkYXRpb24gcmVhc29uc1xuICAgICAgbGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgY29uc3QgYXBwbGllZERhdGEgPSBbZGF0YSwgLi4uYXJnc107XG4gICAgICAvLyBGSVhNRTogbm90IHN1cmUgYWJvdXQgdGhpcyBhcHByb2FjaCwgdHNjIGNvbXBsYWluc1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgX3RyYW5zZm9ybS5hcHBseSh1cGxvYWRTdHJlYW0sIGFwcGxpZWREYXRhKTtcbiAgICB9O1xuXG4gICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpOiB2b2lkID0+IHtcbiAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEZvcmJpZGRlbigpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHVwbG9hZFN0cmVhbTtcbiAgICB9XG5cbiAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCk6IHZvaWQgPT4ge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBcImNhbid0IHVwbG9hZCB0aGlzIHBhY2thZ2VcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGxvYWRTdHJlYW07XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdGVTdHJlYW06IElVcGxvYWRUYXJiYWxsID0gc3RvcmFnZS53cml0ZVRhcmJhbGwoZmlsZW5hbWUpO1xuXG4gICAgd3JpdGVTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLkZJTEVfRVhJU1RfRVJST1IgfHwgZXJyLmNvZGUgPT09IEhUVFBfU1RBVFVTLkNPTkZMSUNUKSB7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRDb25mbGljdCgpKTtcbiAgICAgICAgdXBsb2FkU3RyZWFtLmFib3J0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuTk9fU1VDSF9GSUxFX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgcGFja2FnZSBleGlzdHMgdG8gdGhyb3cgYW4gYXBwcm9wcmlhdGUgbWVzc2FnZVxuICAgICAgICB0aGlzLmdldFBhY2thZ2VNZXRhZGF0YShuYW1lLCBmdW5jdGlvbiAoX2VycjogVmVyZGFjY2lvRXJyb3IsIF9yZXM6IFBhY2thZ2UpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoX2Vycikge1xuICAgICAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgX2Vycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3cml0ZVN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIC8vIHJlLWVtaXR0aW5nIG9wZW4gYmVjYXVzZSBpdCdzIGhhbmRsZWQgaW4gc3RvcmFnZS5qc1xuICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ29wZW4nKTtcbiAgICB9KTtcblxuICAgIHdyaXRlU3RyZWFtLm9uKCdzdWNjZXNzJywgKCk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlcihkYXRhLCBjYik6IHZvaWQge1xuICAgICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzW2ZpbGVuYW1lXSA9IHtcbiAgICAgICAgICAgIHNoYXN1bTogc2hhT25lSGFzaC5kaWdlc3QoJ2hleCcpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdzdWNjZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdXBsb2FkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgd3JpdGVTdHJlYW0uYWJvcnQoKTtcbiAgICB9O1xuXG4gICAgdXBsb2FkU3RyZWFtLmRvbmUgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0QmFkRGF0YSgncmVmdXNpbmcgdG8gYWNjZXB0IHplcm8tbGVuZ3RoIGZpbGUnKSk7XG4gICAgICAgIHdyaXRlU3RyZWFtLmFib3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVN0cmVhbS5kb25lKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVwbG9hZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcblxuICAgIHJldHVybiB1cGxvYWRTdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGFyYmFsbC5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gZmlsZW5hbWVcbiAgICogQHJldHVybiB7UmVhZFRhcmJhbGx9XG4gICAqL1xuICBwdWJsaWMgZ2V0VGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBJUmVhZFRhcmJhbGwge1xuICAgIGFzc2VydCh2YWxpZGF0ZU5hbWUoZmlsZW5hbWUpKTtcblxuICAgIGNvbnN0IHN0b3JhZ2U6IElQYWNrYWdlU3RvcmFnZSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbVN1Y2Nlc3NSZWFkVGFyQmFsbChzdG9yYWdlLCBmaWxlbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyZWFtIHRoYXQgZW1pdHMgYSByZWFkIGZhaWx1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge1JlYWRUYXJiYWxsfVxuICAgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlKCk6IElSZWFkVGFyYmFsbCB7XG4gICAgY29uc3Qgc3RyZWFtOiBJUmVhZFRhcmJhbGwgPSBuZXcgUmVhZFRhcmJhbGwoe30pO1xuXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKTogdm9pZCA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCB0aGlzLl9nZXRGaWxlTm90QXZhaWxhYmxlKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyZWFtIHRoYXQgZW1pdHMgdGhlIHRhcmJhbGwgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmFnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7UmVhZFRhcmJhbGx9XG4gICAqL1xuICBwcml2YXRlIF9zdHJlYW1TdWNjZXNzUmVhZFRhckJhbGwoc3RvcmFnZTogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzdHJlYW06IElSZWFkVGFyYmFsbCA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG4gICAgY29uc3QgcmVhZFRhcmJhbGxTdHJlYW0gPSBzdG9yYWdlLnJlYWRUYXJiYWxsKGZpbGVuYW1lKTtcbiAgICBjb25zdCBlNDA0ID0gRXJyb3JDb2RlLmdldE5vdEZvdW5kO1xuXG4gICAgc3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgaWYgKF8uaXNOaWwocmVhZFRhcmJhbGxTdHJlYW0pID09PSBmYWxzZSkge1xuICAgICAgICByZWFkVGFyYmFsbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuTk9fU1VDSF9GSUxFX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZTQwNCgnbm8gc3VjaCBmaWxlIGF2YWlsYWJsZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignY29udGVudC1sZW5ndGgnLCBmdW5jdGlvbiAoY29udGVudCk6IHZvaWQge1xuICAgICAgc3RyZWFtLmVtaXQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIC8vIHJlLWVtaXR0aW5nIG9wZW4gYmVjYXVzZSBpdCdzIGhhbmRsZWQgaW4gc3RvcmFnZS5qc1xuICAgICAgc3RyZWFtLmVtaXQoJ29wZW4nKTtcbiAgICAgIHJlYWRUYXJiYWxsU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBwYWNrYWdlIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2VNZXRhZGF0YShuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayA9ICgpOiB2b2lkID0+IHt9KTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogSVBhY2thZ2VTdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWRQYWNrYWdlKG5hbWUsIHN0b3JhZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggYSBsb2NhbCBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IHN0YXJ0S2V5XG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHB1YmxpYyBzZWFyY2goc3RhcnRLZXk6IHN0cmluZywgb3B0aW9uczogYW55KTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZFRhcmJhbGwoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5fc2VhcmNoRWFjaFBhY2thZ2UoXG4gICAgICAoaXRlbTogUGFja2FnZSwgY2I6IENhbGxiYWNrQWN0aW9uKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGl0ZW0udGltZSA+IHBhcnNlSW50KHN0YXJ0S2V5LCAxMCkpIHtcbiAgICAgICAgICB0aGlzLmdldFBhY2thZ2VNZXRhZGF0YShpdGVtLm5hbWUsIChlcnI6IFZlcmRhY2Npb0Vycm9yLCBkYXRhOiBQYWNrYWdlKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoaXRlbS50aW1lKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJlcGFyZVNlYXJjaFBhY2thZ2UoZGF0YSwgdGltZSk7XG4gICAgICAgICAgICBpZiAoXy5pc05pbChyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzdHJlYW0ucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBvbkVuZChlcnIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHdyYXBwZXIgdGhhdCBwcm92aWRlIGFjY2VzcyB0byB0aGUgcGFja2FnZSBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBrZ05hbWUgcGFja2FnZSBuYW1lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBwcml2YXRlIF9nZXRMb2NhbFN0b3JhZ2UocGtnTmFtZTogc3RyaW5nKTogSVBhY2thZ2VTdG9yYWdlIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUGx1Z2luLmdldFBhY2thZ2VTdG9yYWdlKHBrZ05hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBqc29uIGZpbGUgZnJvbSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBfcmVhZFBhY2thZ2UobmFtZTogc3RyaW5nLCBzdG9yYWdlOiBhbnksIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHN0b3JhZ2UucmVhZFBhY2thZ2UobmFtZSwgKGVyciwgcmVzdWx0KTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gU1RPUkFHRS5OT19TVUNIX0ZJTEVfRVJST1IgfHwgZXJyLmNvZGUgPT09IEhUVFBfU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Tm90Rm91bmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2ludGVybmFsRXJyb3IoZXJyLCBTVE9SQUdFLlBBQ0tBR0VfRklMRV9OQU1FLCAnZXJyb3IgcmVhZGluZycpKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyLCBub3JtYWxpemVQYWNrYWdlKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhbGtzIHRocm91Z2ggZWFjaCBwYWNrYWdlIGFuZCBjYWxscyBgb25fcGFja2FnZWAgb24gdGhlbS5cbiAgICogQHBhcmFtIHsqfSBvblBhY2thZ2VcbiAgICogQHBhcmFtIHsqfSBvbkVuZFxuICAgKi9cbiAgcHJpdmF0ZSBfc2VhcmNoRWFjaFBhY2thZ2Uob25QYWNrYWdlOiBvblNlYXJjaFBhY2thZ2UsIG9uRW5kOiBvbkVuZFNlYXJjaFBhY2thZ2UpOiB2b2lkIHtcbiAgICAvLyBzYXZlIHdhaXQgd2hldGhlciBwbHVnaW4gc3RpbGwgZG8gbm90IHN1cHBvcnQgc2VhcmNoIGZ1bmN0aW9uYWxpdHlcbiAgICBpZiAoXy5pc05pbCh0aGlzLnN0b3JhZ2VQbHVnaW4uc2VhcmNoKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigncGx1Z2luIHNlYXJjaCBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICBvbkVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3JhZ2VQbHVnaW4uc2VhcmNoKG9uUGFja2FnZSwgb25FbmQsIHZhbGlkYXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGVpdGhlciBhIHByZXZpb3VzIGNyZWF0ZWQgbG9jYWwgcGFja2FnZSBvciBhIGJvaWxlcnBsYXRlLlxuICAgKiBAcGFyYW0geyp9IHBrZ05hbWVcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHByaXZhdGUgX3JlYWRDcmVhdGVQYWNrYWdlKHBrZ05hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogYW55ID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKHBrZ05hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICB0aGlzLl9jcmVhdGVOZXdQYWNrYWdlKHBrZ05hbWUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdG9yYWdlLnJlYWRQYWNrYWdlKHBrZ05hbWUsIChlcnIsIGRhdGEpOiB2b2lkID0+IHtcbiAgICAgIC8vIFRPRE86IHJhY2UgY29uZGl0aW9uXG4gICAgICBpZiAoXy5pc05pbChlcnIpID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuTk9fU1VDSF9GSUxFX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICBkYXRhID0gZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUocGtnTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2ludGVybmFsRXJyb3IoZXJyLCBTVE9SQUdFLlBBQ0tBR0VfRklMRV9OQU1FLCAnZXJyb3IgcmVhZGluZycpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBub3JtYWxpemVQYWNrYWdlKGRhdGEpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2NyZWF0ZU5ld1BhY2thZ2UobmFtZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiBDYWxsYmFjayB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5vcm1hbGl6ZVBhY2thZ2UoZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUobmFtZSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW50ZXJuYWwgZXJyb3JcbiAgICogQHBhcmFtIHsqfSBlcnJcbiAgICogQHBhcmFtIHsqfSBmaWxlXG4gICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEVycm9yIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIF9pbnRlcm5hbEVycm9yKGVycjogc3RyaW5nLCBmaWxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IFZlcmRhY2Npb0Vycm9yIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcih7IGVycjogZXJyLCBmaWxlOiBmaWxlIH0sIGAke21lc3NhZ2V9ICBAe2ZpbGV9OiBAeyFlcnIubWVzc2FnZX1gKTtcblxuICAgIHJldHVybiBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gbmFtZSBwYWNrYWdlIG5hbWVcbiAgICogQHBhcmFtIHsqfSB1cGRhdGVIYW5kbGVyIGZ1bmN0aW9uKHBhY2thZ2UsIGNiKSAtIHVwZGF0ZSBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrIGNhbGxiYWNrIHRoYXQgZ2V0cyBpbnZva2VkIGFmdGVyIGl0J3MgYWxsIHVwZGF0ZWRcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwcml2YXRlIF91cGRhdGVQYWNrYWdlKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB1cGRhdGVIYW5kbGVyOiBTdG9yYWdlVXBkYXRlQ2FsbGJhY2ssXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrQWN0aW9uXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IElQYWNrYWdlU3RvcmFnZSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICB9XG5cbiAgICBzdG9yYWdlLnVwZGF0ZVBhY2thZ2UoXG4gICAgICBuYW1lLFxuICAgICAgdXBkYXRlSGFuZGxlcixcbiAgICAgIHRoaXMuX3dyaXRlUGFja2FnZS5iaW5kKHRoaXMpLFxuICAgICAgbm9ybWFsaXplUGFja2FnZSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHJldmlzaW9uIChfcmV2KSBzdHJpbmcgZm9yIGEgcGFja2FnZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0ganNvblxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHJpdmF0ZSBfd3JpdGVQYWNrYWdlKG5hbWU6IHN0cmluZywganNvbjogUGFja2FnZSwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogYW55ID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgc3RvcmFnZS5zYXZlUGFja2FnZShuYW1lLCB0aGlzLl9zZXREZWZhdWx0UmV2aXNpb24oanNvbiksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NldERlZmF1bHRSZXZpc2lvbihqc29uOiBQYWNrYWdlKTogUGFja2FnZSB7XG4gICAgLy8gY2FsY3VsYXRlIHJldmlzaW9uIGZyb20gY291Y2ggZGJcbiAgICBpZiAoXy5pc1N0cmluZyhqc29uLl9yZXYpID09PSBmYWxzZSkge1xuICAgICAganNvbi5fcmV2ID0gU1RPUkFHRS5ERUZBVUxUX1JFVklTSU9OO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgaW50ZW5kZWQgaW4gZGVidWcgbW9kZSB3ZSBkbyBub3Qgd2FudCBtb2RpZnkgdGhlIHN0b3JlIHJldmlzaW9uXG4gICAgaWYgKF8uaXNOaWwodGhpcy5jb25maWcuX2RlYnVnKSkge1xuICAgICAganNvbi5fcmV2ID0gZ2VuZXJhdGVSZXZpc2lvbihqc29uLl9yZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVsZXRlQXR0YWNobWVudHMoc3RvcmFnZTogYW55LCBhdHRhY2htZW50czogc3RyaW5nW10sIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgeyBsOiBhdHRhY2htZW50cy5sZW5ndGggfSxcbiAgICAgIGBbc3RvcmFnZS9fZGVsZXRlQXR0YWNobWVudHNdIGRlbGV0ZSBhdHRhY2htZW50cyB0b3RhbDogQHtsfWBcbiAgICApO1xuICAgIGNvbnN0IHVubGlua05leHQgPSBmdW5jdGlvbiAoY2IpOiB2b2lkIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoYXR0YWNobWVudHMpKSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gYXR0YWNobWVudHMuc2hpZnQoKTtcbiAgICAgIHN0b3JhZ2UuZGVsZXRlUGFja2FnZShhdHRhY2htZW50LCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIHVubGlua05leHQoY2IpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHVubGlua05leHQoZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgLy8gdHJ5IHRvIHVubGluayB0aGUgZGlyZWN0b3J5LCBidXQgaWdub3JlIGVycm9ycyBiZWNhdXNlIGl0IGNhbiBmYWlsXG4gICAgICBzdG9yYWdlLnJlbW92ZVBhY2thZ2UoZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoZSBkaXN0IGZpbGUgcmVtYWlucyBhcyB0aGUgc2FtZSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXBMaW5rS2V5IHJlZ2lzdHJ5IGtleVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbChoYXNoOiBEaXN0RmlsZSwgdXBMaW5rS2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBpZiB3ZSBnb3QgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIGEga25vd24gcmVnaXN0cnksXG4gICAgLy8gdXNlIHRoZSBzYW1lIHByb3RvY29sIGZvciB0aGUgdGFyYmFsbFxuICAgIC8vXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ybGlkd2thL3Npbm9waWEvaXNzdWVzLzE2NlxuICAgIGNvbnN0IHRhcmJhbGxVcmw6IGFueSA9IFVybE5vZGUucGFyc2UoaGFzaC51cmwpO1xuICAgIGNvbnN0IHVwbGlua1VybDogYW55ID0gVXJsTm9kZS5wYXJzZSh0aGlzLmNvbmZpZy51cGxpbmtzW3VwTGlua0tleV0udXJsKTtcblxuICAgIGlmICh1cGxpbmtVcmwuaG9zdCA9PT0gdGFyYmFsbFVybC5ob3N0KSB7XG4gICAgICB0YXJiYWxsVXJsLnByb3RvY29sID0gdXBsaW5rVXJsLnByb3RvY29sO1xuICAgICAgaGFzaC5yZWdpc3RyeSA9IHVwTGlua0tleTtcbiAgICAgIGhhc2gudXJsID0gVXJsTm9kZS5mb3JtYXQodGFyYmFsbFVybCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNlY3JldChjb25maWc6IENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlY3JldEtleSA9IGF3YWl0IHRoaXMuc3RvcmFnZVBsdWdpbi5nZXRTZWNyZXQoKTtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4uc2V0U2VjcmV0KGNvbmZpZy5jaGVja1NlY3JldEtleShzZWNyZXRLZXkpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRTdG9yYWdlKGNvbmZpZzogQ29uZmlnLCBsb2dnZXI6IExvZ2dlcik6IElQbHVnaW5TdG9yYWdlPENvbmZpZz4ge1xuICAgIGNvbnN0IFN0b3JhZ2UgPSB0aGlzLl9sb2FkU3RvcmVQbHVnaW4oKTtcblxuICAgIGlmIChfLmlzTmlsKFN0b3JhZ2UpKSB7XG4gICAgICBhc3NlcnQodGhpcy5jb25maWcuc3RvcmFnZSwgJ0NPTkZJRzogc3RvcmFnZSBwYXRoIG5vdCBkZWZpbmVkJyk7XG4gICAgICByZXR1cm4gbmV3IExvY2FsRGF0YWJhc2UodGhpcy5jb25maWcsIGxvZ2dlcik7XG4gICAgfVxuICAgIHJldHVybiBTdG9yYWdlIGFzIElQbHVnaW5TdG9yYWdlPENvbmZpZz47XG4gIH1cblxuICBwcml2YXRlIF9sb2FkU3RvcmVQbHVnaW4oKTogSVBsdWdpblN0b3JhZ2U8Q29uZmlnPiB8IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbl9wYXJhbXMgPSB7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlclxuICAgIH07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIGNvbnN0IHBsdWdpbnM6IElQbHVnaW5TdG9yYWdlPENvbmZpZz5bXSA9IGxvYWRQbHVnaW48SVBsdWdpblN0b3JhZ2U8Q29uZmlnPj4oXG4gICAgICB0aGlzLmNvbmZpZyxcbiAgICAgIHRoaXMuY29uZmlnLnN0b3JlLFxuICAgICAgcGx1Z2luX3BhcmFtcyxcbiAgICAgIChwbHVnaW4pOiBJUGx1Z2luU3RvcmFnZTxDb25maWc+ID0+IHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5nZXRQYWNrYWdlU3RvcmFnZTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIF8uaGVhZChwbHVnaW5zKTtcbiAgfVxuXG4gIHB1YmxpYyBzYXZlVG9rZW4odG9rZW46IFRva2VuKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuc3RvcmFnZVBsdWdpbi5zYXZlVG9rZW4pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBFcnJvckNvZGUuZ2V0Q29kZShIVFRQX1NUQVRVUy5TRVJWSUNFX1VOQVZBSUxBQkxFLCBTVVBQT1JUX0VSUk9SUy5QTFVHSU5fTUlTU0lOR19JTlRFUkZBQ0UpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4uc2F2ZVRva2VuKHRva2VuKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVUb2tlbih1c2VyOiBzdHJpbmcsIHRva2VuS2V5OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zdG9yYWdlUGx1Z2luLmRlbGV0ZVRva2VuKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuU0VSVklDRV9VTkFWQUlMQUJMRSwgU1VQUE9SVF9FUlJPUlMuUExVR0lOX01JU1NJTkdfSU5URVJGQUNFKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUGx1Z2luLmRlbGV0ZVRva2VuKHVzZXIsIHRva2VuS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkVG9rZW5zKGZpbHRlcjogVG9rZW5GaWx0ZXIpOiBQcm9taXNlPFRva2VuW10+IHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuc3RvcmFnZVBsdWdpbi5yZWFkVG9rZW5zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuU0VSVklDRV9VTkFWQUlMQUJMRSwgU1VQUE9SVF9FUlJPUlMuUExVR0lOX01JU1NJTkdfSU5URVJGQUNFKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUGx1Z2luLnJlYWRUb2tlbnMoZmlsdGVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2NhbFN0b3JhZ2U7XG4iXX0=