"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = publish;
exports.publishPackage = publishPackage;
exports.unPublishPackage = unPublishPackage;
exports.removeTarball = removeTarball;
exports.addVersion = addVersion;
exports.uploadPackageTarball = uploadPackageTarball;

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash"));

var _mime = _interopRequireDefault(require("mime"));

var _constants = require("../../../lib/constants");

var _utils = require("../../../lib/utils");

var _middleware = require("../../middleware");

var _notify = require("../../../lib/notify");

var _logger = require("../../../lib/logger");

var _storageUtils = require("../../../lib/storage-utils");

var _star = _interopRequireDefault(require("./star"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function publish(router, auth, storage, config) {
  const can = (0, _middleware.allow)(auth);
  /**
   * Publish a package / update package / un/start a package
   *
   * There are multiples scenarios here to be considered:
   *
   * 1. Publish scenario
   *
   * Publish a package consist of at least 1 step (PUT) with a metadata payload.
   * When a package is published, an _attachment property is present that contains the data
   * of the tarball.
   *
   * Example flow of publish.
   *
   *  npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1 9627ms
      npm info lifecycle @scope/test1@1.0.1~publish: @scope/test1@1.0.1
      npm info lifecycle @scope/test1@1.0.1~postpublish: @scope/test1@1.0.1
      + @scope/test1@1.0.1
      npm verb exit [ 0, true ]
   *
   *
   * 2. Unpublish scenario
   *
   * Unpublish consist in 3 steps.
   *  1. Try to fetch  metadata -> if it fails, return 404
   *  2. Compute metadata locally (client side) and send a mutate payload excluding the version to be unpublished
   *    eg: if metadata reflects 1.0.1, 1.0.2 and 1.0.3, the computed metadata won't include 1.0.3.
   *  3. Once the second step has been successfully finished, delete the tarball.
   *
   *  All these steps are consecutive and required, there is no transacions here, if step 3 fails, metadata might
   *  get corrupted.
   *
   *  Note the unpublish call will suffix in the url a /-rev/14-5d500cfce92f90fd revision number, this not
   *  used internally.
   *
   *
   * Example flow of unpublish.
   *
   * npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1680ms
     npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1/-rev/14-5d500cfce92f90fd 956606ms attempt #2
     npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1601ms
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-/test1-1.0.3.tgz/-rev/16-e11c8db282b2d992 19ms
   *
   * 3. Star a package
   *
   * Permissions: start a package depends of the publish and unpublish permissions, there is no specific flag for star or un start.
   * The URL for star is similar to the unpublish (change package format)
   *
   * npm has no enpoint for star a package, rather mutate the metadata and acts as, the difference is the
   * users property which is part of the payload and the body only includes
   *
   * {
    "_id": pkgName,
   	"_rev": "3-b0cdaefc9bdb77c8",
    "users": {
      [username]: boolean value (true, false)
    }
  }
   *
   */

  router.put('/:package/:_rev?/:revision?', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, publishPackage(storage, config, auth));
  /**
   * Un-publishing an entire package.
   *
   * This scenario happens when the first call detect there is only one version remaining
   * in the metadata, then the client decides to DELETE the resource
   * npm http fetch GET 304 http://localhost:4873/@scope%2ftest1?write=true 1076ms (from cache)
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-rev/18-d8ebe3020bd4ac9c 22ms
   */

  router.delete('/:package/-rev/*', can('unpublish'), unPublishPackage(storage)); // removing a tarball

  router.delete('/:package/-/:filename/-rev/:revision', can('unpublish'), can('publish'), removeTarball(storage)); // uploading package tarball

  router.put('/:package/-/:filename/*', can('publish'), (0, _middleware.media)(_constants.HEADERS.OCTET_STREAM), uploadPackageTarball(storage)); // adding a version

  router.put('/:package/:version/-tag/:tag', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, addVersion(storage));
}
/**
 * Publish a package
 */


function publishPackage(storage, config, auth) {
  const starApi = (0, _star.default)(storage);
  return function (req, res, next) {
    const packageName = req.params.package;

    _logger.logger.debug({
      packageName
    }, `publishing or updating a new version for @{packageName}`);
    /**
     * Write tarball of stream data from package clients.
     */


    const createTarball = function (filename, data, cb) {
      const stream = storage.addTarball(packageName, filename);
      stream.on('error', function (err) {
        cb(err);
      });
      stream.on('success', function () {
        cb();
      }); // this is dumb and memory-consuming, but what choices do we have?
      // flow: we need first refactor this file before decides which type use here

      stream.end(Buffer.from(data.data, 'base64'));
      stream.done();
    };
    /**
     * Add new package version in storage
     */


    const createVersion = function (version, metadata, cb) {
      storage.addVersion(packageName, version, metadata, null, cb);
    };
    /**
     * Add new tags in storage
     */


    const addTags = function (tags, cb) {
      storage.mergeTags(packageName, tags, cb);
    };

    const afterChange = function (error, okMessage, metadata) {
      const metadataCopy = _objectSpread({}, metadata);

      const {
        _attachments,
        versions
      } = metadataCopy; // `npm star` wouldn't have attachments
      // and `npm deprecate` would have attachments as a empty object, i.e {}

      if (_lodash.default.isNil(_attachments) || JSON.stringify(_attachments) === '{}') {
        if (error) {
          return next(error);
        }

        res.status(_constants.HTTP_STATUS.CREATED);
        return next({
          ok: okMessage,
          success: true
        });
      } // npm-registry-client 0.3+ embeds tarball into the json upload
      // https://github.com/isaacs/npm-registry-client/commit/e9fbeb8b67f249394f735c74ef11fe4720d46ca0
      // issue https://github.com/rlidwka/sinopia/issues/31, dealing with it here:


      const isInvalidBodyFormat = (0, _utils.isObject)(_attachments) === false || (0, _utils.hasDiffOneKey)(_attachments) || (0, _utils.isObject)(versions) === false || (0, _utils.hasDiffOneKey)(versions);

      if (isInvalidBodyFormat) {
        // npm is doing something strange again
        // if this happens in normal circumstances, report it as a bug
        _logger.logger.info({
          packageName
        }, `wrong package format on publish a package @{packageName}`);

        return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.UNSUPORTED_REGISTRY_CALL));
      }

      if (error && error.status !== _constants.HTTP_STATUS.CONFLICT) {
        return next(error);
      } // at this point document is either created or existed before


      const [firstAttachmentKey] = Object.keys(_attachments);
      createTarball(_path.default.basename(firstAttachmentKey), _attachments[firstAttachmentKey], function (error) {
        if (error) {
          return next(error);
        }

        const versionToPublish = Object.keys(versions)[0];
        const versionMetadataToPublish = versions[versionToPublish];
        versionMetadataToPublish.readme = _lodash.default.isNil(versionMetadataToPublish.readme) === false ? String(versionMetadataToPublish.readme) : '';
        createVersion(versionToPublish, versionMetadataToPublish, function (error) {
          if (error) {
            return next(error);
          }

          addTags(metadataCopy[_constants.DIST_TAGS], async function (error) {
            if (error) {
              return next(error);
            }

            try {
              await (0, _notify.notify)(metadataCopy, config, req.remote_user, `${metadataCopy.name}@${versionToPublish}`);
            } catch (error) {
              _logger.logger.error({
                error
              }, 'notify batch service has failed: @{error}');
            }

            res.status(_constants.HTTP_STATUS.CREATED);
            return next({
              ok: okMessage,
              success: true
            });
          });
        });
      });
    };

    if ((0, _storageUtils.isPublishablePackage)(req.body) === false && (0, _utils.isObject)(req.body.users)) {
      return starApi(req, res, next);
    }

    try {
      const metadata = (0, _utils.validateMetadata)(req.body, packageName); // treating deprecation as updating a package

      if (req.params._rev || (0, _utils.isRelatedToDeprecation)(req.body)) {
        _logger.logger.debug({
          packageName
        }, `updating a new version for @{packageName}`); // we check unpublish permissions, an update is basically remove versions


        const remote = req.remote_user;
        auth.allow_unpublish({
          packageName
        }, remote, error => {
          if (error) {
            _logger.logger.debug({
              packageName
            }, `not allowed to unpublish a version for @{packageName}`);

            return next(error);
          }

          storage.changePackage(packageName, metadata, req.params.revision, function (error) {
            afterChange(error, _constants.API_MESSAGE.PKG_CHANGED, metadata);
          });
        });
      } else {
        _logger.logger.debug({
          packageName
        }, `adding a new version for @{packageName}`);

        storage.addPackage(packageName, metadata, function (error) {
          afterChange(error, _constants.API_MESSAGE.PKG_CREATED, metadata);
        });
      }
    } catch (error) {
      _logger.logger.error({
        packageName
      }, 'error on publish, bad package data for @{packageName}');

      return next(_utils.ErrorCode.getBadData(_constants.API_ERROR.BAD_PACKAGE_DATA));
    }
  };
}
/**
 * un-publish a package
 */


function unPublishPackage(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;

    _logger.logger.debug({
      packageName
    }, `unpublishing @{packageName}`);

    storage.removePackage(packageName, function (err) {
      if (err) {
        return next(err);
      }

      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_REMOVED
      });
    });
  };
}
/**
 * Delete tarball
 */


function removeTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const {
      filename,
      revision
    } = req.params;

    _logger.logger.debug({
      packageName,
      filename,
      revision
    }, `removing a tarball for @{packageName}-@{tarballName}-@{revision}`);

    storage.removeTarball(packageName, filename, revision, function (err) {
      if (err) {
        return next(err);
      }

      res.status(_constants.HTTP_STATUS.CREATED);

      _logger.logger.debug({
        packageName,
        filename,
        revision
      }, `success remove tarball for @{packageName}-@{tarballName}-@{revision}`);

      return next({
        ok: _constants.API_MESSAGE.TARBALL_REMOVED
      });
    });
  };
}
/**
 * Adds a new version
 */


function addVersion(storage) {
  return function (req, res, next) {
    const {
      version,
      tag
    } = req.params;
    const packageName = req.params.package;
    storage.addVersion(packageName, version, req.body, tag, function (error) {
      if (error) {
        return next(error);
      }

      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_PUBLISHED
      });
    });
  };
}
/**
 * uploadPackageTarball
 */


function uploadPackageTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const stream = storage.addTarball(packageName, req.params.filename);
    req.pipe(stream); // checking if end event came before closing

    let complete = false;
    req.on('end', function () {
      complete = true;
      stream.done();
    });
    req.on('close', function () {
      if (!complete) {
        stream.abort();
      }
    });
    stream.on('error', function (err) {
      return res.report_error(err);
    });
    stream.on('success', function () {
      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.TARBALL_UPLOADED
      });
    });
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hcGkvZW5kcG9pbnQvYXBpL3B1Ymxpc2gudHMiXSwibmFtZXMiOlsicHVibGlzaCIsInJvdXRlciIsImF1dGgiLCJzdG9yYWdlIiwiY29uZmlnIiwiY2FuIiwicHV0IiwibWltZSIsImdldFR5cGUiLCJleHBlY3RKc29uIiwicHVibGlzaFBhY2thZ2UiLCJkZWxldGUiLCJ1blB1Ymxpc2hQYWNrYWdlIiwicmVtb3ZlVGFyYmFsbCIsIkhFQURFUlMiLCJPQ1RFVF9TVFJFQU0iLCJ1cGxvYWRQYWNrYWdlVGFyYmFsbCIsImFkZFZlcnNpb24iLCJzdGFyQXBpIiwicmVxIiwicmVzIiwibmV4dCIsInBhY2thZ2VOYW1lIiwicGFyYW1zIiwicGFja2FnZSIsImxvZ2dlciIsImRlYnVnIiwiY3JlYXRlVGFyYmFsbCIsImZpbGVuYW1lIiwiZGF0YSIsImNiIiwic3RyZWFtIiwiYWRkVGFyYmFsbCIsIm9uIiwiZXJyIiwiZW5kIiwiQnVmZmVyIiwiZnJvbSIsImRvbmUiLCJjcmVhdGVWZXJzaW9uIiwidmVyc2lvbiIsIm1ldGFkYXRhIiwiYWRkVGFncyIsInRhZ3MiLCJtZXJnZVRhZ3MiLCJhZnRlckNoYW5nZSIsImVycm9yIiwib2tNZXNzYWdlIiwibWV0YWRhdGFDb3B5IiwiX2F0dGFjaG1lbnRzIiwidmVyc2lvbnMiLCJfIiwiaXNOaWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwiSFRUUF9TVEFUVVMiLCJDUkVBVEVEIiwib2siLCJzdWNjZXNzIiwiaXNJbnZhbGlkQm9keUZvcm1hdCIsImluZm8iLCJFcnJvckNvZGUiLCJnZXRCYWRSZXF1ZXN0IiwiQVBJX0VSUk9SIiwiVU5TVVBPUlRFRF9SRUdJU1RSWV9DQUxMIiwiQ09ORkxJQ1QiLCJmaXJzdEF0dGFjaG1lbnRLZXkiLCJPYmplY3QiLCJrZXlzIiwiUGF0aCIsImJhc2VuYW1lIiwidmVyc2lvblRvUHVibGlzaCIsInZlcnNpb25NZXRhZGF0YVRvUHVibGlzaCIsInJlYWRtZSIsIlN0cmluZyIsIkRJU1RfVEFHUyIsInJlbW90ZV91c2VyIiwibmFtZSIsImJvZHkiLCJ1c2VycyIsIl9yZXYiLCJyZW1vdGUiLCJhbGxvd191bnB1Ymxpc2giLCJjaGFuZ2VQYWNrYWdlIiwicmV2aXNpb24iLCJBUElfTUVTU0FHRSIsIlBLR19DSEFOR0VEIiwiYWRkUGFja2FnZSIsIlBLR19DUkVBVEVEIiwiZ2V0QmFkRGF0YSIsIkJBRF9QQUNLQUdFX0RBVEEiLCJyZW1vdmVQYWNrYWdlIiwiUEtHX1JFTU9WRUQiLCJUQVJCQUxMX1JFTU9WRUQiLCJ0YWciLCJQS0dfUFVCTElTSEVEIiwicGlwZSIsImNvbXBsZXRlIiwiYWJvcnQiLCJyZXBvcnRfZXJyb3IiLCJUQVJCQUxMX1VQTE9BREVEIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFPQTs7QUFDQTs7QUFTQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUVlLFNBQVNBLE9BQVQsQ0FDYkMsTUFEYSxFQUViQyxJQUZhLEVBR2JDLE9BSGEsRUFJYkMsTUFKYSxFQUtQO0FBQ04sUUFBTUMsR0FBRyxHQUFHLHVCQUFNSCxJQUFOLENBQVo7QUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNFRCxFQUFBQSxNQUFNLENBQUNLLEdBQVAsQ0FDRSw2QkFERixFQUVFRCxHQUFHLENBQUMsU0FBRCxDQUZMLEVB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RyxDQUFDOEUsSUFBSixDQUFTbEUsTUFBVCxFQUh3RixDQUt4Rjs7QUFDQSxRQUFJbUUsUUFBUSxHQUFHLEtBQWY7QUFDQS9FLElBQUFBLEdBQUcsQ0FBQ2MsRUFBSixDQUFPLEtBQVAsRUFBYyxZQUFZO0FBQ3hCaUUsTUFBQUEsUUFBUSxHQUFHLElBQVg7QUFDQW5FLE1BQUFBLE1BQU0sQ0FBQ08sSUFBUDtBQUNELEtBSEQ7QUFLQW5CLElBQUFBLEdBQUcsQ0FBQ2MsRUFBSixDQUFPLE9BQVAsRUFBZ0IsWUFBWTtBQUMxQixVQUFJLENBQUNpRSxRQUFMLEVBQWU7QUFDYm5FLFFBQUFBLE1BQU0sQ0FBQ29FLEtBQVA7QUFDRDtBQUNGLEtBSkQ7QUFNQXBFLElBQUFBLE1BQU0sQ0FBQ0UsRUFBUCxDQUFVLE9BQVYsRUFBbUIsVUFBVUMsR0FBVixFQUFlO0FBQ2hDLGFBQU9kLEdBQUcsQ0FBQ2dGLFlBQUosQ0FBaUJsRSxHQUFqQixDQUFQO0FBQ0QsS0FGRDtBQUlBSCxJQUFBQSxNQUFNLENBQUNFLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQVk7QUFDL0JiLE1BQUFBLEdBQUcsQ0FBQ21DLE1BQUosQ0FBV0MsdUJBQVlDLE9BQXZCO0FBQ0EsYUFBT3BDLElBQUksQ0FBQztBQUNWcUMsUUFBQUEsRUFBRSxFQUFFNEIsdUJBQVllO0FBRE4sT0FBRCxDQUFYO0FBR0QsS0FMRDtBQU1ELEdBNUJEO0FBNkJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG1pbWUgZnJvbSAnbWltZSc7XG5cbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHsgQ29uZmlnLCBDYWxsYmFjaywgTWVyZ2VUYWdzLCBWZXJzaW9uLCBQYWNrYWdlIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBBUElfTUVTU0FHRSwgSEVBREVSUywgRElTVF9UQUdTLCBBUElfRVJST1IsIEhUVFBfU1RBVFVTIH0gZnJvbSAnLi4vLi4vLi4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICB2YWxpZGF0ZU1ldGFkYXRhLFxuICBpc09iamVjdCxcbiAgRXJyb3JDb2RlLFxuICBoYXNEaWZmT25lS2V5LFxuICBpc1JlbGF0ZWRUb0RlcHJlY2F0aW9uXG59IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgeyBtZWRpYSwgZXhwZWN0SnNvbiwgYWxsb3cgfSBmcm9tICcuLi8uLi9taWRkbGV3YXJlJztcbmltcG9ydCB7IG5vdGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi9ub3RpZnknO1xuXG5pbXBvcnQge1xuICBJQXV0aCxcbiAgJFJlc3BvbnNlRXh0ZW5kLFxuICAkUmVxdWVzdEV4dGVuZCxcbiAgJE5leHRGdW5jdGlvblZlcixcbiAgSVN0b3JhZ2VIYW5kbGVyXG59IGZyb20gJy4uLy4uLy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgaXNQdWJsaXNoYWJsZVBhY2thZ2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc3RvcmFnZS11dGlscyc7XG5pbXBvcnQgc3RhciBmcm9tICcuL3N0YXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwdWJsaXNoKFxuICByb3V0ZXI6IFJvdXRlcixcbiAgYXV0aDogSUF1dGgsXG4gIHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlcixcbiAgY29uZmlnOiBDb25maWdcbik6IHZvaWQge1xuICBjb25zdCBjYW4gPSBhbGxvdyhhdXRoKTtcblxuICAvKipcbiAgICogUHVibGlzaCBhIHBhY2thZ2UgLyB1cGRhdGUgcGFja2FnZSAvIHVuL3N0YXJ0IGEgcGFja2FnZVxuICAgKlxuICAgKiBUaGVyZSBhcmUgbXVsdGlwbGVzIHNjZW5hcmlvcyBoZXJlIHRvIGJlIGNvbnNpZGVyZWQ6XG4gICAqXG4gICAqIDEuIFB1Ymxpc2ggc2NlbmFyaW9cbiAgICpcbiAgICogUHVibGlzaCBhIHBhY2thZ2UgY29uc2lzdCBvZiBhdCBsZWFzdCAxIHN0ZXAgKFBVVCkgd2l0aCBhIG1ldGFkYXRhIHBheWxvYWQuXG4gICAqIFdoZW4gYSBwYWNrYWdlIGlzIHB1Ymxpc2hlZCwgYW4gX2F0dGFjaG1lbnQgcHJvcGVydHkgaXMgcHJlc2VudCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhXG4gICAqIG9mIHRoZSB0YXJiYWxsLlxuICAgKlxuICAgKiBFeGFtcGxlIGZsb3cgb2YgcHVibGlzaC5cbiAgICpcbiAgICogIG5wbSBodHRwIGZldGNoIFBVVCAyMDEgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxIDk2Mjdtc1xuICAgICAgbnBtIGluZm8gbGlmZWN5Y2xlIEBzY29wZS90ZXN0MUAxLjAuMX5wdWJsaXNoOiBAc2NvcGUvdGVzdDFAMS4wLjFcbiAgICAgIG5wbSBpbmZvIGxpZmVjeWNsZSBAc2NvcGUvdGVzdDFAMS4wLjF+cG9zdHB1Ymxpc2g6IEBzY29wZS90ZXN0MUAxLjAuMVxuICAgICAgKyBAc2NvcGUvdGVzdDFAMS4wLjFcbiAgICAgIG5wbSB2ZXJiIGV4aXQgWyAwLCB0cnVlIF1cbiAgICpcbiAgICpcbiAgICogMi4gVW5wdWJsaXNoIHNjZW5hcmlvXG4gICAqXG4gICAqIFVucHVibGlzaCBjb25zaXN0IGluIDMgc3RlcHMuXG4gICAqICAxLiBUcnkgdG8gZmV0Y2ggIG1ldGFkYXRhIC0+IGlmIGl0IGZhaWxzLCByZXR1cm4gNDA0XG4gICAqICAyLiBDb21wdXRlIG1ldGFkYXRhIGxvY2FsbHkgKGNsaWVudCBzaWRlKSBhbmQgc2VuZCBhIG11dGF0ZSBwYXlsb2FkIGV4Y2x1ZGluZyB0aGUgdmVyc2lvbiB0byBiZSB1bnB1Ymxpc2hlZFxuICAgKiAgICBlZzogaWYgbWV0YWRhdGEgcmVmbGVjdHMgMS4wLjEsIDEuMC4yIGFuZCAxLjAuMywgdGhlIGNvbXB1dGVkIG1ldGFkYXRhIHdvbid0IGluY2x1ZGUgMS4wLjMuXG4gICAqICAzLiBPbmNlIHRoZSBzZWNvbmQgc3RlcCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZmluaXNoZWQsIGRlbGV0ZSB0aGUgdGFyYmFsbC5cbiAgICpcbiAgICogIEFsbCB0aGVzZSBzdGVwcyBhcmUgY29uc2VjdXRpdmUgYW5kIHJlcXVpcmVkLCB0aGVyZSBpcyBubyB0cmFuc2FjaW9ucyBoZXJlLCBpZiBzdGVwIDMgZmFpbHMsIG1ldGFkYXRhIG1pZ2h0XG4gICAqICBnZXQgY29ycnVwdGVkLlxuICAgKlxuICAgKiAgTm90ZSB0aGUgdW5wdWJsaXNoIGNhbGwgd2lsbCBzdWZmaXggaW4gdGhlIHVybCBhIC8tcmV2LzE0LTVkNTAwY2ZjZTkyZjkwZmQgcmV2aXNpb24gbnVtYmVyLCB0aGlzIG5vdFxuICAgKiAgdXNlZCBpbnRlcm5hbGx5LlxuICAgKlxuICAgKlxuICAgKiBFeGFtcGxlIGZsb3cgb2YgdW5wdWJsaXNoLlxuICAgKlxuICAgKiBucG0gaHR0cCBmZXRjaCBHRVQgMjAwIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MT93cml0ZT10cnVlIDE2ODBtc1xuICAgICBucG0gaHR0cCBmZXRjaCBQVVQgMjAxIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MS8tcmV2LzE0LTVkNTAwY2ZjZTkyZjkwZmQgOTU2NjA2bXMgYXR0ZW1wdCAjMlxuICAgICBucG0gaHR0cCBmZXRjaCBHRVQgMjAwIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MT93cml0ZT10cnVlIDE2MDFtc1xuICAgICBucG0gaHR0cCBmZXRjaCBERUxFVEUgMjAxIGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MS8tL3Rlc3QxLTEuMC4zLnRnei8tcmV2LzE2LWUxMWM4ZGIyODJiMmQ5OTIgMTltc1xuICAgKlxuICAgKiAzLiBTdGFyIGEgcGFja2FnZVxuICAgKlxuICAgKiBQZXJtaXNzaW9uczogc3RhcnQgYSBwYWNrYWdlIGRlcGVuZHMgb2YgdGhlIHB1Ymxpc2ggYW5kIHVucHVibGlzaCBwZXJtaXNzaW9ucywgdGhlcmUgaXMgbm8gc3BlY2lmaWMgZmxhZyBmb3Igc3RhciBvciB1biBzdGFydC5cbiAgICogVGhlIFVSTCBmb3Igc3RhciBpcyBzaW1pbGFyIHRvIHRoZSB1bnB1Ymxpc2ggKGNoYW5nZSBwYWNrYWdlIGZvcm1hdClcbiAgICpcbiAgICogbnBtIGhhcyBubyBlbnBvaW50IGZvciBzdGFyIGEgcGFja2FnZSwgcmF0aGVyIG11dGF0ZSB0aGUgbWV0YWRhdGEgYW5kIGFjdHMgYXMsIHRoZSBkaWZmZXJlbmNlIGlzIHRoZVxuICAgKiB1c2VycyBwcm9wZXJ0eSB3aGljaCBpcyBwYXJ0IG9mIHRoZSBwYXlsb2FkIGFuZCB0aGUgYm9keSBvbmx5IGluY2x1ZGVzXG4gICAqXG4gICAqIHtcblx0XHQgIFwiX2lkXCI6IHBrZ05hbWUsXG5cdCAgXHRcIl9yZXZcIjogXCIzLWIwY2RhZWZjOWJkYjc3YzhcIixcblx0XHQgIFwidXNlcnNcIjoge1xuXHRcdCAgICBbdXNlcm5hbWVdOiBib29sZWFuIHZhbHVlICh0cnVlLCBmYWxzZSlcblx0XHQgIH1cblx0fVxuICAgKlxuICAgKi9cbiAgcm91dGVyLnB1dChcbiAgICAnLzpwYWNrYWdlLzpfcmV2Py86cmV2aXNpb24/JyxcbiAgICBjYW4oJ3B1Ymxpc2gnKSxcbiAgICBtZWRpYShtaW1lLmdldFR5cGUoJ2pzb24nKSksXG4gICAgZXhwZWN0SnNvbixcbiAgICBwdWJsaXNoUGFja2FnZShzdG9yYWdlLCBjb25maWcsIGF1dGgpXG4gICk7XG5cbiAgLyoqXG4gICAqIFVuLXB1Ymxpc2hpbmcgYW4gZW50aXJlIHBhY2thZ2UuXG4gICAqXG4gICAqIFRoaXMgc2NlbmFyaW8gaGFwcGVucyB3aGVuIHRoZSBmaXJzdCBjYWxsIGRldGVjdCB0aGVyZSBpcyBvbmx5IG9uZSB2ZXJzaW9uIHJlbWFpbmluZ1xuICAgKiBpbiB0aGUgbWV0YWRhdGEsIHRoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIERFTEVURSB0aGUgcmVzb3VyY2VcbiAgICogbnBtIGh0dHAgZmV0Y2ggR0VUIDMwNCBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDE/d3JpdGU9dHJ1ZSAxMDc2bXMgKGZyb20gY2FjaGUpXG4gICAgIG5wbSBodHRwIGZldGNoIERFTEVURSAyMDEgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxLy1yZXYvMTgtZDhlYmUzMDIwYmQ0YWM5YyAyMm1zXG4gICAqL1xuICByb3V0ZXIuZGVsZXRlKCcvOnBhY2thZ2UvLXJldi8qJywgY2FuKCd1bnB1Ymxpc2gnKSwgdW5QdWJsaXNoUGFja2FnZShzdG9yYWdlKSk7XG5cbiAgLy8gcmVtb3ZpbmcgYSB0YXJiYWxsXG4gIHJvdXRlci5kZWxldGUoXG4gICAgJy86cGFja2FnZS8tLzpmaWxlbmFtZS8tcmV2LzpyZXZpc2lvbicsXG4gICAgY2FuKCd1bnB1Ymxpc2gnKSxcbiAgICBjYW4oJ3B1Ymxpc2gnKSxcbiAgICByZW1vdmVUYXJiYWxsKHN0b3JhZ2UpXG4gICk7XG5cbiAgLy8gdXBsb2FkaW5nIHBhY2thZ2UgdGFyYmFsbFxuICByb3V0ZXIucHV0KFxuICAgICcvOnBhY2thZ2UvLS86ZmlsZW5hbWUvKicsXG4gICAgY2FuKCdwdWJsaXNoJyksXG4gICAgbWVkaWEoSEVBREVSUy5PQ1RFVF9TVFJFQU0pLFxuICAgIHVwbG9hZFBhY2thZ2VUYXJiYWxsKHN0b3JhZ2UpXG4gICk7XG5cbiAgLy8gYWRkaW5nIGEgdmVyc2lvblxuICByb3V0ZXIucHV0KFxuICAgICcvOnBhY2thZ2UvOnZlcnNpb24vLXRhZy86dGFnJyxcbiAgICBjYW4oJ3B1Ymxpc2gnKSxcbiAgICBtZWRpYShtaW1lLmdldFR5cGUoJ2pzb24nKSksXG4gICAgZXhwZWN0SnNvbixcbiAgICBhZGRWZXJzaW9uKHN0b3JhZ2UpXG4gICk7XG59XG5cbi8qKlxuICogUHVibGlzaCBhIHBhY2thZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlciwgY29uZmlnOiBDb25maWcsIGF1dGg6IElBdXRoKTogYW55IHtcbiAgY29uc3Qgc3RhckFwaSA9IHN0YXIoc3RvcmFnZSk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHJlcS5wYXJhbXMucGFja2FnZTtcblxuICAgIGxvZ2dlci5kZWJ1Zyh7IHBhY2thZ2VOYW1lIH0sIGBwdWJsaXNoaW5nIG9yIHVwZGF0aW5nIGEgbmV3IHZlcnNpb24gZm9yIEB7cGFja2FnZU5hbWV9YCk7XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0YXJiYWxsIG9mIHN0cmVhbSBkYXRhIGZyb20gcGFja2FnZSBjbGllbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGNyZWF0ZVRhcmJhbGwgPSBmdW5jdGlvbiAoZmlsZW5hbWU6IHN0cmluZywgZGF0YSwgY2I6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBzdG9yYWdlLmFkZFRhcmJhbGwocGFja2FnZU5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcyBpcyBkdW1iIGFuZCBtZW1vcnktY29uc3VtaW5nLCBidXQgd2hhdCBjaG9pY2VzIGRvIHdlIGhhdmU/XG4gICAgICAvLyBmbG93OiB3ZSBuZWVkIGZpcnN0IHJlZmFjdG9yIHRoaXMgZmlsZSBiZWZvcmUgZGVjaWRlcyB3aGljaCB0eXBlIHVzZSBoZXJlXG4gICAgICBzdHJlYW0uZW5kKEJ1ZmZlci5mcm9tKGRhdGEuZGF0YSwgJ2Jhc2U2NCcpKTtcbiAgICAgIHN0cmVhbS5kb25lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgcGFja2FnZSB2ZXJzaW9uIGluIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjb25zdCBjcmVhdGVWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IFZlcnNpb24sIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgICAgc3RvcmFnZS5hZGRWZXJzaW9uKHBhY2thZ2VOYW1lLCB2ZXJzaW9uLCBtZXRhZGF0YSwgbnVsbCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbmV3IHRhZ3MgaW4gc3RvcmFnZVxuICAgICAqL1xuICAgIGNvbnN0IGFkZFRhZ3MgPSBmdW5jdGlvbiAodGFnczogTWVyZ2VUYWdzLCBjYjogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAgIHN0b3JhZ2UubWVyZ2VUYWdzKHBhY2thZ2VOYW1lLCB0YWdzLCBjYik7XG4gICAgfTtcblxuICAgIGNvbnN0IGFmdGVyQ2hhbmdlID0gZnVuY3Rpb24gKGVycm9yLCBva01lc3NhZ2UsIG1ldGFkYXRhKTogdm9pZCB7XG4gICAgICBjb25zdCBtZXRhZGF0YUNvcHk6IFBhY2thZ2UgPSB7IC4uLm1ldGFkYXRhIH07XG5cbiAgICAgIGNvbnN0IHsgX2F0dGFjaG1lbnRzLCB2ZXJzaW9ucyB9ID0gbWV0YWRhdGFDb3B5O1xuXG4gICAgICAvLyBgbnBtIHN0YXJgIHdvdWxkbid0IGhhdmUgYXR0YWNobWVudHNcbiAgICAgIC8vIGFuZCBgbnBtIGRlcHJlY2F0ZWAgd291bGQgaGF2ZSBhdHRhY2htZW50cyBhcyBhIGVtcHR5IG9iamVjdCwgaS5lIHt9XG4gICAgICBpZiAoXy5pc05pbChfYXR0YWNobWVudHMpIHx8IEpTT04uc3RyaW5naWZ5KF9hdHRhY2htZW50cykgPT09ICd7fScpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgICBvazogb2tNZXNzYWdlLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5wbS1yZWdpc3RyeS1jbGllbnQgMC4zKyBlbWJlZHMgdGFyYmFsbCBpbnRvIHRoZSBqc29uIHVwbG9hZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ucG0tcmVnaXN0cnktY2xpZW50L2NvbW1pdC9lOWZiZWI4YjY3ZjI0OTM5NGY3MzVjNzRlZjExZmU0NzIwZDQ2Y2EwXG4gICAgICAvLyBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy8zMSwgZGVhbGluZyB3aXRoIGl0IGhlcmU6XG4gICAgICBjb25zdCBpc0ludmFsaWRCb2R5Rm9ybWF0ID1cbiAgICAgICAgaXNPYmplY3QoX2F0dGFjaG1lbnRzKSA9PT0gZmFsc2UgfHxcbiAgICAgICAgaGFzRGlmZk9uZUtleShfYXR0YWNobWVudHMpIHx8XG4gICAgICAgIGlzT2JqZWN0KHZlcnNpb25zKSA9PT0gZmFsc2UgfHxcbiAgICAgICAgaGFzRGlmZk9uZUtleSh2ZXJzaW9ucyk7XG5cbiAgICAgIGlmIChpc0ludmFsaWRCb2R5Rm9ybWF0KSB7XG4gICAgICAgIC8vIG5wbSBpcyBkb2luZyBzb21ldGhpbmcgc3RyYW5nZSBhZ2FpblxuICAgICAgICAvLyBpZiB0aGlzIGhhcHBlbnMgaW4gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIHJlcG9ydCBpdCBhcyBhIGJ1Z1xuICAgICAgICBsb2dnZXIuaW5mbyh7IHBhY2thZ2VOYW1lIH0sIGB3cm9uZyBwYWNrYWdlIGZvcm1hdCBvbiBwdWJsaXNoIGEgcGFja2FnZSBAe3BhY2thZ2VOYW1lfWApO1xuICAgICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0QmFkUmVxdWVzdChBUElfRVJST1IuVU5TVVBPUlRFRF9SRUdJU1RSWV9DQUxMKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvciAmJiBlcnJvci5zdGF0dXMgIT09IEhUVFBfU1RBVFVTLkNPTkZMSUNUKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXQgdGhpcyBwb2ludCBkb2N1bWVudCBpcyBlaXRoZXIgY3JlYXRlZCBvciBleGlzdGVkIGJlZm9yZVxuICAgICAgY29uc3QgW2ZpcnN0QXR0YWNobWVudEtleV0gPSBPYmplY3Qua2V5cyhfYXR0YWNobWVudHMpO1xuXG4gICAgICBjcmVhdGVUYXJiYWxsKFxuICAgICAgICBQYXRoLmJhc2VuYW1lKGZpcnN0QXR0YWNobWVudEtleSksXG4gICAgICAgIF9hdHRhY2htZW50c1tmaXJzdEF0dGFjaG1lbnRLZXldLFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2ZXJzaW9uVG9QdWJsaXNoID0gT2JqZWN0LmtleXModmVyc2lvbnMpWzBdO1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25NZXRhZGF0YVRvUHVibGlzaCA9IHZlcnNpb25zW3ZlcnNpb25Ub1B1Ymxpc2hdO1xuXG4gICAgICAgICAgdmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoLnJlYWRtZSA9XG4gICAgICAgICAgICBfLmlzTmlsKHZlcnNpb25NZXRhZGF0YVRvUHVibGlzaC5yZWFkbWUpID09PSBmYWxzZVxuICAgICAgICAgICAgICA/IFN0cmluZyh2ZXJzaW9uTWV0YWRhdGFUb1B1Ymxpc2gucmVhZG1lKVxuICAgICAgICAgICAgICA6ICcnO1xuXG4gICAgICAgICAgY3JlYXRlVmVyc2lvbih2ZXJzaW9uVG9QdWJsaXNoLCB2ZXJzaW9uTWV0YWRhdGFUb1B1Ymxpc2gsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkVGFncyhtZXRhZGF0YUNvcHlbRElTVF9UQUdTXSwgYXN5bmMgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbm90aWZ5KFxuICAgICAgICAgICAgICAgICAgbWV0YWRhdGFDb3B5LFxuICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgcmVxLnJlbW90ZV91c2VyLFxuICAgICAgICAgICAgICAgICAgYCR7bWV0YWRhdGFDb3B5Lm5hbWV9QCR7dmVyc2lvblRvUHVibGlzaH1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvciB9LCAnbm90aWZ5IGJhdGNoIHNlcnZpY2UgaGFzIGZhaWxlZDogQHtlcnJvcn0nKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KHsgb2s6IG9rTWVzc2FnZSwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAoaXNQdWJsaXNoYWJsZVBhY2thZ2UocmVxLmJvZHkpID09PSBmYWxzZSAmJiBpc09iamVjdChyZXEuYm9keS51c2VycykpIHtcbiAgICAgIHJldHVybiBzdGFyQXBpKHJlcSwgcmVzLCBuZXh0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB2YWxpZGF0ZU1ldGFkYXRhKHJlcS5ib2R5LCBwYWNrYWdlTmFtZSk7XG4gICAgICAvLyB0cmVhdGluZyBkZXByZWNhdGlvbiBhcyB1cGRhdGluZyBhIHBhY2thZ2VcbiAgICAgIGlmIChyZXEucGFyYW1zLl9yZXYgfHwgaXNSZWxhdGVkVG9EZXByZWNhdGlvbihyZXEuYm9keSkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKHsgcGFja2FnZU5hbWUgfSwgYHVwZGF0aW5nIGEgbmV3IHZlcnNpb24gZm9yIEB7cGFja2FnZU5hbWV9YCk7XG4gICAgICAgIC8vIHdlIGNoZWNrIHVucHVibGlzaCBwZXJtaXNzaW9ucywgYW4gdXBkYXRlIGlzIGJhc2ljYWxseSByZW1vdmUgdmVyc2lvbnNcbiAgICAgICAgY29uc3QgcmVtb3RlID0gcmVxLnJlbW90ZV91c2VyO1xuICAgICAgICBhdXRoLmFsbG93X3VucHVibGlzaCh7IHBhY2thZ2VOYW1lIH0sIHJlbW90ZSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoeyBwYWNrYWdlTmFtZSB9LCBgbm90IGFsbG93ZWQgdG8gdW5wdWJsaXNoIGEgdmVyc2lvbiBmb3IgQHtwYWNrYWdlTmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdG9yYWdlLmNoYW5nZVBhY2thZ2UocGFja2FnZU5hbWUsIG1ldGFkYXRhLCByZXEucGFyYW1zLnJldmlzaW9uLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFmdGVyQ2hhbmdlKGVycm9yLCBBUElfTUVTU0FHRS5QS0dfQ0hBTkdFRCwgbWV0YWRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zyh7IHBhY2thZ2VOYW1lIH0sIGBhZGRpbmcgYSBuZXcgdmVyc2lvbiBmb3IgQHtwYWNrYWdlTmFtZX1gKTtcbiAgICAgICAgc3RvcmFnZS5hZGRQYWNrYWdlKHBhY2thZ2VOYW1lLCBtZXRhZGF0YSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgYWZ0ZXJDaGFuZ2UoZXJyb3IsIEFQSV9NRVNTQUdFLlBLR19DUkVBVEVELCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoeyBwYWNrYWdlTmFtZSB9LCAnZXJyb3Igb24gcHVibGlzaCwgYmFkIHBhY2thZ2UgZGF0YSBmb3IgQHtwYWNrYWdlTmFtZX0nKTtcbiAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRCYWREYXRhKEFQSV9FUlJPUi5CQURfUEFDS0FHRV9EQVRBKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIHVuLXB1Ymxpc2ggYSBwYWNrYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1blB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG5cbiAgICBsb2dnZXIuZGVidWcoeyBwYWNrYWdlTmFtZSB9LCBgdW5wdWJsaXNoaW5nIEB7cGFja2FnZU5hbWV9YCk7XG4gICAgc3RvcmFnZS5yZW1vdmVQYWNrYWdlKHBhY2thZ2VOYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLkNSRUFURUQpO1xuICAgICAgcmV0dXJuIG5leHQoeyBvazogQVBJX01FU1NBR0UuUEtHX1JFTU9WRUQgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRGVsZXRlIHRhcmJhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhcmJhbGwoc3RvcmFnZTogSVN0b3JhZ2VIYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHJlcS5wYXJhbXMucGFja2FnZTtcbiAgICBjb25zdCB7IGZpbGVuYW1lLCByZXZpc2lvbiB9ID0gcmVxLnBhcmFtcztcblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIHsgcGFja2FnZU5hbWUsIGZpbGVuYW1lLCByZXZpc2lvbiB9LFxuICAgICAgYHJlbW92aW5nIGEgdGFyYmFsbCBmb3IgQHtwYWNrYWdlTmFtZX0tQHt0YXJiYWxsTmFtZX0tQHtyZXZpc2lvbn1gXG4gICAgKTtcbiAgICBzdG9yYWdlLnJlbW92ZVRhcmJhbGwocGFja2FnZU5hbWUsIGZpbGVuYW1lLCByZXZpc2lvbiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5DUkVBVEVEKTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICB7IHBhY2thZ2VOYW1lLCBmaWxlbmFtZSwgcmV2aXNpb24gfSxcbiAgICAgICAgYHN1Y2Nlc3MgcmVtb3ZlIHRhcmJhbGwgZm9yIEB7cGFja2FnZU5hbWV9LUB7dGFyYmFsbE5hbWV9LUB7cmV2aXNpb259YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXh0KHsgb2s6IEFQSV9NRVNTQUdFLlRBUkJBTExfUkVNT1ZFRCB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbi8qKlxuICogQWRkcyBhIG5ldyB2ZXJzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRWZXJzaW9uKHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB2ZXJzaW9uLCB0YWcgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG5cbiAgICBzdG9yYWdlLmFkZFZlcnNpb24ocGFja2FnZU5hbWUsIHZlcnNpb24sIHJlcS5ib2R5LCB0YWcsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5DUkVBVEVEKTtcbiAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgb2s6IEFQSV9NRVNTQUdFLlBLR19QVUJMSVNIRURcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIHVwbG9hZFBhY2thZ2VUYXJiYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRQYWNrYWdlVGFyYmFsbChzdG9yYWdlOiBJU3RvcmFnZUhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgbmV4dDogJE5leHRGdW5jdGlvblZlcik6IHZvaWQge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcmVxLnBhcmFtcy5wYWNrYWdlO1xuICAgIGNvbnN0IHN0cmVhbSA9IHN0b3JhZ2UuYWRkVGFyYmFsbChwYWNrYWdlTmFtZSwgcmVxLnBhcmFtcy5maWxlbmFtZSk7XG4gICAgcmVxLnBpcGUoc3RyZWFtKTtcblxuICAgIC8vIGNoZWNraW5nIGlmIGVuZCBldmVudCBjYW1lIGJlZm9yZSBjbG9zaW5nXG4gICAgbGV0IGNvbXBsZXRlID0gZmFsc2U7XG4gICAgcmVxLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb21wbGV0ZSA9IHRydWU7XG4gICAgICBzdHJlYW0uZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgcmVxLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgc3RyZWFtLmFib3J0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIHJlcy5yZXBvcnRfZXJyb3IoZXJyKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICByZXR1cm4gbmV4dCh7XG4gICAgICAgIG9rOiBBUElfTUVTU0FHRS5UQVJCQUxMX1VQTE9BREVEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbiJdfQ==